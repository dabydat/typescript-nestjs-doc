# üéØ Generics

Generics es uno de los conceptos m√°s importantes de TypeScript y la base sobre la que se construye todo el DI (Inyecci√≥n de Dependencias) de NestJS.

---

## üìë √çndice de Contenidos

1. **[¬øQu√© Son los Generics?](#qu√©-son-los-generics)** - Introducci√≥n y conceptos b√°sicos
2. **[Generic Constraints](#generic-constraints-solo-ciertos-tipos-permitidos)** - Restringir tipos aceptados
3. **[M√∫ltiples Type Parameters](#m√∫ltiples-type-parameters-relacionando-tipos)** - Relacionar diferentes tipos
   - [Caso Real: Mapper Gen√©rico](#caso-real-mapper-gen√©rico)
4. **[Generic Repository en NestJS](#caso-real-generic-repository-en-nestjs)** - Patr√≥n BaseRepository<T>
5. **[Generic Classes: Result Pattern](#generic-classes-patr√≥n-resultt-e)** - Manejo de errores funcional
6. **[Default Type Parameters](#default-type-parameters)** - Valores por defecto en tipos
7. **[Acceso Type-Safe a Propiedades: `keyof`](#acceso-type-safe-a-propiedades-keyof)** - Type safety en propiedades
   - [Caso Real: Update Parcial Type-Safe](#caso-real-update-parcial-type-safe)
8. **[Resumen](#resumen-lo-que-aprendiste)** - Lo que aprendiste
9. **[Checklist](#-checklist-¬øentendiste-generics)** - Validaci√≥n de aprendizaje

---

## ¬øQu√© Son los Generics?

Imagina que quieres escribir una funci√≥n que sea **reutilizable pero type-safe**. Por ejemplo, una funci√≥n que tome cualquier tipo de array y devuelva el primer elemento.

Sin generics, tendr√≠as dos opciones malas:

1. **Usas `any`:** Funciona, pero pierdes toda la informaci√≥n de tipos (¬°enemigo de TypeScript!)
2. **Haces m√∫ltiples versiones:** Una para n√∫meros, otra para strings, otra para objetos... ¬°pesadilla de mantenimiento!

Generics resuelven esto permiti√©ndote escribir una funci√≥n *una sola vez* que funcione para **cualquier tipo** pero manteniendo la seguridad de tipos.

### El Problema: Usando `any`. Algo que deber√≠as evitar

```typescript
// ‚ùå MALO: Usamos any
function first(arr: any[]): any {
  return arr[0];
}

const num = first([1, 2, 3]); // Type: any üòû 
// ¬øEs number? ¬øPodemos hacer operaciones? TypeScript no sabe
const str = first(['a', 'b']); // Type: any üòû 
// ¬øEs string? ¬øTiene m√©todo .toUpperCase()? TypeScript no lo sabe
```

El problema: **TypeScript perdi√≥ toda la informaci√≥n de tipos**. Podr√≠as escribir c√≥digo incorrecto y TypeScript no te lo dir√≠a hasta runtime.

### La Soluci√≥n es: Generics

```typescript
//   BIEN: Usamos generics
function first<T>(arr: T[]): T {
  return arr[0];
}

const num = first([1, 2, 3]); // Type: number   
// TypeScript sabe que es number, autocomplete funciona
const str = first(['a', 'b']); // Type: string   
// TypeScript sabe que es string, puedes usar .toUpperCase()
```

### ¬øC√≥mo Funciona Esto?

`T` es un **tipo variable** (placeholder). Cuando llamas `first([1, 2, 3])`, TypeScript ve que pasas un array de n√∫meros y **autom√°ticamente sustituye `T` por `number`**. Cuando llamas `first(['a', 'b'])`, sustituye `T` por `string`.

Es como si TypeScript creara autom√°ticamente dos versiones de la funci√≥n:
- `function first(arr: number[]): number`
- `function first(arr: string[]): string`

Pero lo mejor: **¬°Lo escribe TypeScript por ti!** C√≥digo limpio, reutilizable, y seguro.

---

## Generic Constraints: "Solo Ciertos Tipos Permitidos"

A veces no quieres que un generic acepte **cualquier tipo**. Quieres restringirlo. Por ejemplo: "que solo acepte tipos que tengan una propiedad `length`".

Para eso usamos `extends`:

```typescript
// Sin constraint: acepta cualquier tipo
function identity<T>(value: T): T {
  return value;
}

// Con constraint: solo tipos que tienen 'length'
interface HasLength {
  length: number;
}

function logLength<T extends HasLength>(value: T): T {
  console.log(value.length); //   Seguro: sabemos que T tiene length
  return value;
}

//   Estos S√ç funcionan
logLength('hello'); // string tiene propiedad .length
logLength([1, 2, 3]); // arrays tienen propiedad .length
logLength({ length: 10 }); // este objeto tiene propiedad .length

// ‚ùå Esto NO funciona
// logLength(123); // Error: number no tiene propiedad .length
// TypeScript grita: "¬°El tipo 'number' no cumple con el constraint HasLength!"
```

### ¬øQu√© Significa `extends`?

`T extends HasLength` significa: "**T puede ser cualquier tipo, pero SOLO si tiene la propiedad `length`**".

Es como un filtro. TypeScript valida en compile time que el tipo que pases cumpla con el constraint. Si no, ¬°error inmediato!

---

## M√∫ltiples Type Parameters: Relacionando Tipos

```typescript
// Con 2 tipos relacionados
function pair<T, U>(first: T, second: U): [T, U] {
  return [first, second];
}

const p1 = pair(1, 'hello'); // Type: [number, string]  
const p2 = pair(true, { x: 10 }); // Type: [boolean, { x: number }]  
```

Esto es √∫til cuando quieres **relacionar m√∫ltiples tipos** que pueden ser diferentes entre s√≠.

### Caso Real: Mapper Gen√©rico

En NestJS, frecuentemente transformas datos entre capas:
- **DTO ‚Üí Entity** (datos del cliente al modelo)
- **Entity ‚Üí Response** (modelo a respuesta segura)

Generics te permite escribir mappers type-safe:

```typescript
interface Mapper<TSource, TDestination> {
  map(source: TSource): TDestination;
}

// DTO ‚Üí Entity mapper
class CreateUserDto {
  name: string;
  email: string;
}

class User {
  id: string;
  name: string;
  email: string;
  password: string; // Nunca en respuesta
}

class UserDtoToEntityMapper implements Mapper<CreateUserDto, User> {
  map(dto: CreateUserDto): User {
    const user = new User();
    user.name = dto.name;
    user.email = dto.email;
    return user;
  }
}

// Entity ‚Üí Response mapper (solo datos p√∫blicos)
class UserResponse {
  id: string;
  name: string;
  email: string;
}

class UserToResponseMapper implements Mapper<User, UserResponse> {
  map(user: User): UserResponse {
    return {
      id: user.id,
      name: user.name,
      email: user.email,
      // ‚úÖ password no se expone aqu√≠
    };
  }
}

// En service
@Injectable()
export class UserService {
  constructor(
    private readonly dtoToEntityMapper: UserDtoToEntityMapper,
    private readonly entityToResponseMapper: UserToResponseMapper,
  ) {}

  async createUser(dto: CreateUserDto): Promise<UserResponse> {
    const entity = this.dtoToEntityMapper.map(dto); // Type-safe conversion
    const saved = await this.repository.save(entity);
    return this.entityToResponseMapper.map(saved); // Type-safe response
  }
}
```

**Beneficio:** TypeScript valida autom√°ticamente que tu mapper recibe el tipo correcto y devuelve el tipo esperado.

---

## Caso Real: Generic Repository en NestJS

**¬øPor qu√© NestJS ama los generics?** Porque resuelven un problema com√∫n: tienes muchas entidades (User, Product, Order, etc.) y cada una necesita un repository. Sin generics, escribir√≠as c√≥digo repetitivo.

Con generics, escribes UNA clase que funciona para todas:

```typescript
import { Injectable } from '@nestjs/common';
import { Repository, FindOptionsWhere } from 'typeorm';

//   Un repository gen√©rico que funciona para CUALQUIER entidad
@Injectable()
export class BaseRepository<T> {
  constructor(private readonly repository: Repository<T>) {}

  async findAll(): Promise<T[]> {
    return this.repository.find();
  }

  async findById(id: string): Promise<T | null> {
    return this.repository.findOne({
      where: { id } as FindOptionsWhere<T>,
    });
  }

  async create(entity: Partial<T>): Promise<T> {
    const created = this.repository.create(entity);
    return this.repository.save(created);
  }

  async update(id: string, entity: Partial<T>): Promise<T> {
    await this.repository.update(id, entity as any);
    return this.findById(id);
  }

  async delete(id: string): Promise<void> {
    await this.repository.delete(id);
  }
}

// Definir entidades
class User {
  id: string;
  name: string;
  email: string;
}

class Product {
  id: string;
  title: string;
  price: number;
}

//   Usar el mismo repository para diferentes entidades
@Injectable()
export class UserService {
  constructor(private userRepo: BaseRepository<User>) {}

  async getUser(id: string): Promise<User | null> {
    return this.userRepo.findById(id); // TypeScript sabe que es User | null  
  }

  async createUser(data: Partial<User>): Promise<User> {
    return this.userRepo.create(data); // TypeScript sabe que es User  
  }
}

@Injectable()
export class ProductService {
  constructor(private productRepo: BaseRepository<Product>) {}

  async getProduct(id: string): Promise<Product | null> {
    return this.productRepo.findById(id); // TypeScript sabe que es Product | null  
  }

  async createProduct(data: Partial<Product>): Promise<Product> {
    return this.productRepo.create(data); // TypeScript sabe que es Product  
  }
}
```

**La magia:** Escribiste el repository UNA VEZ y funciona para todas las entidades. Si necesitas un nuevo repository, solo haces `new BaseRepository<Order>(...)` y ¬°autom√°ticamente TypeScript sabe qu√© es!

---

## Generic Classes: Patr√≥n Result<T, E>

A veces quieres manejar errores sin usar `try/catch`. El patr√≥n **Result** es popular en lenguajes funcionales y es incre√≠blemente √∫til:

```typescript
// Result<T, E> = Result<Tipo de √©xito, Tipo de error>
class Result<T, E = Error> {
  private constructor(
    private readonly _value?: T,
    private readonly _error?: E,
  ) {}

  static ok<T, E = Error>(value: T): Result<T, E> {
    return new Result<T, E>(value, undefined);
  }

  static err<T, E = Error>(error: E): Result<T, E> {
    return new Result<T, E>(undefined, error);
  }

  isOk(): boolean {
    return this._error === undefined;
  }

  isErr(): boolean {
    return this._error !== undefined;
  }

  unwrap(): T {
    if (this.isErr()) {
      throw new Error('Called unwrap on Error result');
    }
    return this._value!;
  }

  unwrapOr(defaultValue: T): T {
    return this.isOk() ? this._value! : defaultValue;
  }

  error(): E | undefined {
    return this._error;
  }

  map<U>(fn: (value: T) => U): Result<U, E> {
    if (this.isOk()) {
      return Result.ok(fn(this._value!));
    }
    return Result.err(this._error!);
  }
}

// ¬øPor qu√© es genial? TypeScript sabe si tienes √©xito o error
const result1: Result<string> = Result.ok('Success!'); // Type: Result<string, Error>
const result2: Result<number> = Result.err(new Error('Oops')); // Type: Result<number, Error>

if (result1.isOk()) {
  const value = result1.unwrap(); // Type: string   
}
```

### En NestJS: Servicio con Result Pattern

```typescript
@Injectable()
export class UserService {
  constructor(private readonly userRepository: Repository<User>) {}

  async findUser(id: string): Promise<Result<User, string>> {
    try {
      const user = await this.userRepository.findOne({ where: { id } });

      if (!user) {
        return Result.err('Usuario no encontrado');
      }

      return Result.ok(user);
    } catch (error) {
      return Result.err(`Error al buscar usuario: ${error.message}`);
    }
  }
}

// En controller
@Get(':id')
async getUser(@Param('id') id: string): Promise<any> {
  const result = await this.userService.findUser(id);

  if (result.isErr()) {
    throw new NotFoundException(result.error());
  }

  return result.unwrap(); // Type: User   
}
```

**Ventaja:** Sin `try/catch`, con type safety, y puedes chainear operaciones con `.map()`.

---

## Default Type Parameters

A veces quieres que un generic tenga un valor por defecto:

```typescript
// Sin default: siempre debes especificar TMeta
class ResponseWrapper<T, TMeta> {
  constructor(public data: T, public meta: TMeta) {}
}

const response1 = new ResponseWrapper({ id: 1 }, { page: 1 });
// Debes pasar meta siempre

// Con default: TMeta es Record<string, any> si no lo especificas
class ResponseWrapperWithDefault<T, TMeta = Record<string, any>> {
  constructor(public data: T, public meta?: TMeta) {}
}

// Usa meta por defecto
const response2 = new ResponseWrapperWithDefault({ id: 1 });
// Type: ResponseWrapperWithDefault<{ id: number }, Record<string, any>>   

// Meta customizado
interface PaginationMeta {
  page: number;
  total: number;
}

const response3 = new ResponseWrapperWithDefault(
  [{ id: 1 }, { id: 2 }],
  { page: 1, total: 100 }
);
// Type: ResponseWrapperWithDefault<{ id: number }[], PaginationMeta>   
```

**Caso Real:** DTOs en NestJS con metadata opcional

```typescript
@Injectable()
export class ResponseService {
  // TResponse es el tipo de datos, TMeta tiene default
  buildResponse<TResponse, TMeta = { timestamp: string }>(
    data: TResponse,
    meta?: TMeta,
  ) {
    return {
      data,
      meta: meta || { timestamp: new Date().toISOString() },
    };
  }
}

const simpleResponse = this.responseService.buildResponse({ id: 1, name: 'John' });
// metadata es auto-generada

const customResponse = this.responseService.buildResponse(
  { id: 1 },
  { timestamp: '2024-01-01', custom: 'value' }
);
// metadata customizada
```

---

## Acceso Type-Safe a Propiedades: `keyof`

Hay un patr√≥n muy potente: acceder a propiedades de un objeto de forma type-safe usando `keyof`.

```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user = { id: 1, name: 'John', email: 'john@example.com' };

const name = getProperty(user, 'name'); // Type: string  
const id = getProperty(user, 'id'); // Type: number  
// getProperty(user, 'invalid'); // ‚ùå Error: 'invalid' no es una propiedad de user
```

**¬øC√≥mo funciona?** `K extends keyof T` significa: "K debe ser una de las propiedades de T". Si intentas pasar una propiedad que no existe, ¬°error en compile time!

### Caso Real: Update Parcial Type-Safe

Imagina que quieres actualizar SOLO un campo de un usuario, pero TypeScript debe validar que el valor tenga el tipo correcto:

```typescript
@Injectable()
export class UserService {
  async updateField<K extends keyof User>(
    id: string,
    field: K,          // Solo propiedades v√°lidas de User
    value: User[K],    // El tipo debe coincidir con el campo
  ): Promise<void> {
    await this.repository.update(id, {
      [field]: value,
    });
  }
}

// Uso:
await userService.updateField(userId, 'name', 'John'); //   OK: string para string
await userService.updateField(userId, 'email', 'john@example.com'); //   OK: string para string

// Errores atrapados:
// await userService.updateField(userId, 'name', 123); // ‚ùå Error: 123 no es string
// await userService.updateField(userId, 'invalidField', 'test'); // ‚ùå Error: invalidField no existe
```

**Resultado:** ¬°Nunca m√°s actualizar√°s un campo con el tipo incorrecto accidentalmente!

---

## Resumen: Lo Que Aprendiste

-   **Generics b√°sicos:** `<T>` como placeholder de tipo
-   **Constraints:** `T extends Type` para restringir qu√© tipos acepta
-   **M√∫ltiples par√°metros:** `<T, U>` para relacionar tipos
-   **keyof:** Acceso type-safe a propiedades
-   **NestJS:** Repositories gen√©ricos que funcionan para cualquier entidad
-   **Nombra bien:** `TEntity`, `TDto`, `TResponse` en lugar de `T`, `U`, `V`

**Lo importante:** Generics es la base de todo en NestJS. DI, Repositories, Servicios... todo usa generics para ser flexible y type-safe.

¬°Pr√≥ximo paso: Utility Types! All√° aprenderemos trucos incre√≠bles para transformar tipos.

**[2Ô∏è‚É£ Utility Types: Transformaciones Built-in](./2.Utility-Types[TypeScript].md)** ‚Äî Partial, Pick, Omit, Record, Exclude, Extract, NonNullable, ReturnType, Parameters, Awaited