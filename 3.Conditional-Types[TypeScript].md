# üîÄ Conditional Types: Tipos que Dependen de Condiciones

Ya dominamos **Generics** y **Utility Types**. Ahora llega lo m√°s PODEROSO: **Conditional Types**. 

Imagina que necesitas un tipo que cambie seg√∫n condiciones. ¬ø`string` ‚Üí `string[]`, `number` ‚Üí `string`? Los conditional types hacen exactamente eso. **Son como ternarios (`? :`) pero para tipos.**

---

## ÔøΩ √çndice de Contenidos

1. **[¬øQu√© Son Conditional Types?](#qu√©-son-conditional-types)** - Conceptos b√°sicos
2. **[Sintaxis: T extends U ? X : Y](#sintaxis-t-extends-u--x--y)** - Ternarios para tipos
3. **[Distributive Conditional Types](#distributive-conditional-types)** - Unions y distribuci√≥n
4. **[Infer Keyword: Extraer Tipos](#infer-keyword-extraer-tipos)** - `infer` la magia
5. **[Inferir Return Types](#inferir-return-types)** - De funciones
6. **[Inferir Parameters](#inferir-parameters)** - De par√°metros
7. **[Recursive Conditional Types](#recursive-conditional-types)** - Tipos anidados
8. **[KeysOfType: Filtrar por Tipo](#keystype-filtrar-por-tipo)** - Propiedades espec√≠ficas
9. **[Casos Pr√°cticos NestJS](#casos-pr√°cticos-nestjs)** - Real world examples
10. **[Resumen](#resumen-lo-que-aprendiste)** - Recap
11. **[Checklist](#-checklist-¬øentendiste-conditional-types)** - Validaci√≥n

---

## ¬øQu√© Son Conditional Types?

Un **conditional type** es un tipo que cambia seg√∫n una condici√≥n. Sintaxis:

$$T \text{ extends } U \text{ ? } X \text{ : } Y$$

Si `T` extiende `U`, el tipo es `X`. Si no, es `Y`.

**Ejemplo mental:**
```typescript
// ¬øEs string?
IsString<'hello'> ‚Üí true ‚úÖ
IsString<42> ‚Üí false ‚úÖ
```

Sin conditional types, tendr√≠as que crear m√∫ltiples tipos manualmente. Con ellos, un solo tipo se adapta. ¬°Magia! ‚ú®

---

## Sintaxis: T extends U ? X : Y

**¬øC√≥mo funciona?**

```typescript
// Tipo simple: ¬øEs string?
type IsString<T> = T extends string ? true : false;

type A = IsString<string>; // true ‚úÖ
type B = IsString<number>; // false ‚úÖ
type C = IsString<'hello'>; // true ‚úÖ (literal extiende string)
```

### Caso Real: Formato de Respuesta Din√°mico

```typescript
// Tipo que cambia seg√∫n formato solicitado
type ResponseFormat<T> = T extends 'json'
  ? { data: any; status: number } // JSON: objeto
  : T extends 'xml'
  ? string // XML: string
  : T extends 'binary'
  ? Buffer // Binary: buffer
  : never;

type JsonResponse = ResponseFormat<'json'>; 
// Type: { data: any; status: number } ‚úÖ

type XmlResponse = ResponseFormat<'xml'>; 
// Type: string ‚úÖ
```

### ¬øPor Qu√© Importa?

Sin conditional types, necesitar√≠as:
```typescript
// ‚ùå Repetir tipos manualmente
type JsonResponse = { data: any; status: number };
type XmlResponse = string;
type BinaryResponse = Buffer;
```

Con conditional types:
```typescript
// ‚úÖ Un tipo que se adapta
type ResponseFormat<T> = T extends 'json'
  ? { data: any; status: number }
  : ...
```

---

## Distributive Conditional Types

**Aqu√≠ viene lo tricky:** Cuando `T` es una **union**, TypeScript aplica el conditional a **cada miembro** autom√°ticamente.

```typescript
type ToArray<T> = T extends any ? T[] : never;

// Con tipo simple
type SingleArray = ToArray<string>; 
// Type: string[] ‚úÖ

// Con union: se distribuye
type UnionArray = ToArray<string | number>;
// Type: string[] | number[] ‚úÖ
// NO es (string | number)[], ¬°esto es importante!
```

### ¬øC√≥mo Funciona la Distribuci√≥n?

```typescript
ToArray<string | number>
// ‚Üì Distribuye cada miembro
ToArray<string> | ToArray<number>
// ‚Üì
string[] | number[]
```

### Caso Real: Extraer Solo Strings de Union

```typescript
type ExtractStrings<T> = T extends string ? T : never;

type MixedUnion = 'hello' | 42 | 'world' | true | 'foo';
type OnlyStrings = ExtractStrings<MixedUnion>;
// Type: 'hello' | 'world' | 'foo' ‚úÖ
// Los types NO-string desaparecen (never se filtra)
```

### Prevenir Distribuci√≥n (Cuando NO Quieres)

Envuelve `T` en un array:

```typescript
// ‚ùå CON distribuci√≥n (default)
type ToArrayDist<T> = T extends any ? T[] : never;
type Dist = ToArrayDist<string | number>; 
// Type: string[] | number[]

// ‚úÖ SIN distribuci√≥n (wrap en [])
type ToArrayNoDist<T> = [T] extends [any] ? T[] : never;
type NoDist = ToArrayNoDist<string | number>; 
// Type: (string | number)[] ‚Üê single array!
```

---

## Infer Keyword: Extraer Tipos

`infer` es CLAVE. Te permite **extraer partes de un tipo** dentro del conditional.

Sintaxis: `infer X` dentro del conditional para capturar tipo.

### Extraer Tipo de Array Element

```typescript
// "Si T es array de algo, infiere qu√© es ese algo"
type ElementType<T> = T extends (infer E)[] ? E : never;

type StringElement = ElementType<string[]>; 
// Type: string ‚úÖ (inferido del array)

type NumberElement = ElementType<number[]>; 
// Type: number ‚úÖ

type NotArray = ElementType<string>; 
// Type: never ‚úÖ (no es array)
```

### Caso Real: Extraer Entity de Repository

```typescript
import { Repository } from 'typeorm';

// "Si T es Repository de algo, infiere qu√© entity es"
type ExtractEntity<T> = T extends Repository<infer E> ? E : never;

class User {
  id: string;
  name: string;
}

class UserRepository extends Repository<User> {}

type InferredEntity = ExtractEntity<UserRepository>;
// Type: User ‚úÖ (autom√°ticamente de UserRepository)

// Uso: Generic service que infiere entity
@Injectable()
export class GenericService<R extends Repository<any>> {
  constructor(private repository: R) {}

  async findById(id: string): Promise<ExtractEntity<R> | null> {
    return this.repository.findOne({ where: { id } as any });
  }

  async create(data: Partial<ExtractEntity<R>>): Promise<ExtractEntity<R>> {
    const entity = this.repository.create(data as any);
    return this.repository.save(entity);
  }
  // Type-safe autom√°ticamente, sin declarar el tipo! ‚úÖ
}
```

---

## Inferir Return Types

Uno de los superpoderes: inferir el tipo de retorno de una funci√≥n.

```typescript
// "Si T es funci√≥n que retorna algo, infiere qu√© retorna"
type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

function getUser() {
  return { id: '1', name: 'John' };
}

type UserType = GetReturnType<typeof getUser>;
// Type: { id: string; name: string } ‚úÖ
// Nunca necesitaste escribir el tipo, lo infiri√≥! üéâ
```

### Caso Real: Inferir de M√©todos Service

```typescript
@Injectable()
export class OrderService {
  async createOrder(data: CreateOrderDto) {
    return {
      id: 'uuid-123',
      ...data,
      status: 'pending' as const,
      createdAt: new Date(),
    };
  }
}

// Inferir tipo exacto SIN duplicar definici√≥n
type CreatedOrder = Awaited<ReturnType<OrderService['createOrder']>>;
// Type: { id: string; ...CreateOrderDto; status: 'pending'; createdAt: Date } ‚úÖ

// Siempre sincronizado con el m√©todo real üîÑ
```

---

## Inferir Parameters

Lo opuesto: extraer los tipos de par√°metros de una funci√≥n.

```typescript
// "Si T es funci√≥n con par√°metros, infiere cu√°les son"
type GetFirstParam<T> = T extends (first: infer P, ...args: any[]) => any
  ? P
  : never;

function createUser(name: string, email: string, age: number) {
  // ...
}

type FirstParam = GetFirstParam<typeof createUser>;
// Type: string ‚úÖ
```

---

## Recursive Conditional Types

**Tipos que se llaman a s√≠ mismos** para manejar estructuras anidadas.

### DeepReadonly: Hacer Todo Readonly

```typescript
// Recursivo: si es objeto, aplica DeepReadonly a sus props
type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends object
    ? DeepReadonly<T[K]> // Recursi√≥n
    : T[K];
};

interface Config {
  server: {
    host: string;
    port: number;
    ssl: { enabled: boolean };
  };
}

type ImmutableConfig = DeepReadonly<Config>;

const config: ImmutableConfig = {
  server: {
    host: 'localhost',
    port: 3000,
    ssl: { enabled: true },
  },
};

// config.server.host = 'other'; // ‚ùå Error: readonly
// config.server.ssl.enabled = false; // ‚ùå Error: readonly (RECURSIVO!)
```

### DeepPartial: Todos los Niveles Opcionales

```typescript
type DeepPartial<T> = {
  [K in keyof T]?: T[K] extends object
    ? DeepPartial<T[K]>
    : T[K];
};

type PartialConfig = DeepPartial<Config>;

const partial: PartialConfig = {
  server: {
    port: 8080, // Solo port, resto opcional ‚úÖ
  },
  // database completamente opcional ‚úÖ
};
```

---

## KeysOfType: Filtrar por Tipo

Tipo que extrae solo las **keys que tienen cierto tipo de value**.

```typescript
// "Dame todas las keys de T cuyo value es tipo V"
type KeysOfType<T, V> = {
  [K in keyof T]: T[K] extends V ? K : never;
}[keyof T];

interface User {
  id: string;
  name: string;
  age: number;
  isActive: boolean;
  createdAt: Date;
}

// Solo keys string
type StringKeys = KeysOfType<User, string>;
// Type: 'id' | 'name' ‚úÖ

// Solo keys number
type NumberKeys = KeysOfType<User, number>;
// Type: 'age' ‚úÖ

// Solo keys Date
type DateKeys = KeysOfType<User, Date>;
// Type: 'createdAt' ‚úÖ
```

---

## Casos Pr√°cticos NestJS

Aqu√≠ es donde brilla todo junto.

### 1. Response Type Din√°mico Seg√∫n Formato

```typescript
type ApiResponse<T, Format extends 'json' | 'xml' = 'json'> =
  Format extends 'json'
    ? { data: T; meta: { timestamp: string } }
    : string; // XML como string

@Controller('users')
export class UserController {
  @Get()
  async getUsers(
    @Query('format') format: 'json' | 'xml',
  ): Promise<ApiResponse<User[], typeof format>> {
    const users = await this.userService.findAll();

    if (format === 'json') {
      return {
        data: users,
        meta: { timestamp: new Date().toISOString() },
      }; // ‚úÖ Type-safe
    }

    return this.convertToXml(users); // string ‚úÖ
  }
}

// Cliente:
const jsonResponse = await getUsers('json'); // Type-safe JSON ‚úÖ
// Type: { data: User[]; meta: { timestamp: string } }

const xmlResponse = await getUsers('xml'); // Type-safe XML ‚úÖ
// Type: string
```

### 2. Type-Safe Event Emitter

```typescript
type EventPayloads = {
  'user.created': { userId: string; email: string };
  'user.updated': { userId: string; changes: Partial<User> };
  'user.deleted': { userId: string };
  'order.created': { orderId: string; total: number };
};

// Conditional: Si E es key de EventPayloads, tipo es EventPayloads[E]
type EventPayload<E extends keyof EventPayloads> = EventPayloads[E];

class TypedEventEmitter {
  emit<E extends keyof EventPayloads>(
    event: E,
    payload: EventPayload<E>, // ‚úÖ Type inferido del evento
  ): void {
    // ...
  }

  on<E extends keyof EventPayloads>(
    event: E,
    handler: (payload: EventPayload<E>) => void,
  ): void {
    // ...
  }
}

// USO TYPE-SAFE:
const emitter = new TypedEventEmitter();

emitter.emit('user.created', {
  userId: '123',
  email: 'john@example.com',
}); // ‚úÖ Email obligatorio

// emitter.emit('user.created', { userId: '123' }); 
// ‚ùå Error: falta email (type-safe!)

emitter.on('order.created', (payload) => {
  console.log(payload.orderId); // Type: string ‚úÖ
  console.log(payload.total); // Type: number ‚úÖ
  // console.log(payload.email); // ‚ùå Error: no existe en order.created
});
```

### 3. Repository Return Types

```typescript
type RepositoryMethod = 'findOne' | 'findMany' | 'create' | 'update' | 'delete';

// Conditional: diferentes retornos seg√∫n m√©todo
type RepositoryReturnType<T, M extends RepositoryMethod> = 
  M extends 'findOne' ? T | null :
  M extends 'findMany' ? T[] :
  M extends 'create' ? T :
  M extends 'update' ? T :
  M extends 'delete' ? void :
  never;

class TypedRepository<T> {
  async execute<M extends RepositoryMethod>(
    method: M,
    ...args: any[]
  ): Promise<RepositoryReturnType<T, M>> {
    // Implementaci√≥n...
    return null as any;
  }
}

// TIPO-SEGURO autom√°ticamente:
const userRepo = new TypedRepository<User>();

const one = await userRepo.execute('findOne', '123'); 
// Type: User | null ‚úÖ

const many = await userRepo.execute('findMany');
// Type: User[] ‚úÖ

const created = await userRepo.execute('create', {...});
// Type: User ‚úÖ

const deleted = await userRepo.execute('delete', '123');
// Type: void ‚úÖ
```

---

## Resumen: Lo Que Aprendiste

- ‚úÖ **Conditional Syntax:** `T extends U ? X : Y` (ternarios para tipos)
- ‚úÖ **Distributive:** Unions se distribuyen autom√°ticamente en conditionals
- ‚úÖ **Infer Keyword:** Capturar/extraer tipos dentro de conditionals
- ‚úÖ **Return Types:** Inferir tipo de retorno de funciones sin duplicaci√≥n
- ‚úÖ **Parameters:** Extraer tipos de par√°metros
- ‚úÖ **Recursive:** Tipos que llaman a s√≠ mismos para estructuras anidadas
- ‚úÖ **KeysOfType:** Filtrar propiedades por tipo de value
- ‚úÖ **Real-World:** Event emitters type-safe, response formats din√°micos, repositories typed

**Lo importante:** Conditional types + `infer` = **Tipos que aprenden de otros tipos**. No escribes redundancia, la evitas. ¬°Escribes menos, TypeScript entiende m√°s!

---

## üìã Checklist: ¬øEntendiste Conditional Types? Tengamos presente lo siguiente:

- ‚úÖ Sintaxis: `T extends U ? X : Y`
- ‚úÖ Distributive: unions se distribuyen autom√°ticamente
- ‚úÖ `infer` para extraer tipos dentro de conditionals
- ‚úÖ Inferir return types de funciones
- ‚úÖ Inferir parameters de funciones
- ‚úÖ Recursive conditionals para estructuras anidadas
- ‚úÖ KeysOfType para filtrar propiedades por tipo
- ‚úÖ Type-safe event emitters con conditionals
- ‚úÖ Response types din√°micos seg√∫n par√°metros
- ‚úÖ Prevenir distribuci√≥n con [T] cuando sea necesario

**üéØ Pr√≥ximo paso:** [4Ô∏è‚É£ Mapped Types](./4.Mapped-Types[TypeScript].md) ‚Äî Transformar y iterar tipos complejos autom√°ticamente.

**üéØ Recuerda:** Conditional types son el puente entre "tipos est√°ticos" e "inteligencia de tipos". Dom√≠nalos y escribir√°s frameworks, no solo aplicaciones.