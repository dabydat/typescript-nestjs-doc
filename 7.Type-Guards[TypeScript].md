# üõ°Ô∏è Type Guards: Averiguar Qu√© Tipo Tiene Cada Cosa

## Introducci√≥n: El Problema

Imagina que tu funci√≥n recibe datos que **pueden ser de varios tipos**:

```typescript
// ‚ùå Problema: No sabemos qu√© tipo es
function process(data: string | number) {
  // ¬øpuedo usar .toUpperCase()? 
  // ¬øo tengo que usar .toFixed()?
  // ¬øc√≥mo s√© cu√°l es?
}
```

Un **type guard** es simplemente preguntar "¬øde qu√© tipo eres?" antes de usarlo. As√≠ TypeScript sabe exactamente qu√© m√©todos puedes usar.

```typescript
// ‚úÖ Soluci√≥n: Preguntar qu√© tipo es
function process(data: string | number) {
  if (typeof data === 'string') {
    // Aqu√≠ TypeScript SABE que es string
    console.log(data.toUpperCase()); // ‚úÖ OK
  } else {
    // Aqu√≠ TypeScript SABE que es number
    console.log(data.toFixed(2)); // ‚úÖ OK
  }
}
```

**Eso es un type guard:** una pregunta que TypeScript entiende y usa para saber qu√© tipo tienes en cada rama.

---

## üìã √çndice - S√∫per Simple

1. [typeof: Preguntar el Tipo Primitivo](#typeof)
2. [instanceof: Preguntar si es Instancia de Clase](#instanceof)
3. [Custom Type Guards: Funciones Propias](#custom)
4. [Discriminated Unions: Propiedades Marcadas](#discriminated)
5. [El Operador 'in': ¬øExiste esta Propiedad?](#in)
6. [Assertion Functions: Asegurar o Explotar](#assertions)
7. [Null/Undefined: Limpiar Tipos Opcionables](#nullable)
8. [Casos Reales en NestJS](#nestjs)
9. [Checklist Final](#checklist)

---

## typeof: Preguntar el Tipo Primitivo {#typeof}

Usa `typeof` para preguntar: ¬øeres string, number, boolean...?

```typescript
// Ejemplo b√°sico
function process(value: string | number) {
  if (typeof value === 'string') {
    // TypeScript sabe: value es string
    console.log(value.toUpperCase()); // ‚úÖ .toUpperCase() existe
  } else {
    // TypeScript sabe: value es number
    console.log(value.toFixed(2)); // ‚úÖ .toFixed() existe
  }
}

process('hola'); // HOLA
process(3.14159); // 3.14
```

`typeof` funciona con estos tipos primitivos:
- `'string'`
- `'number'`
- `'boolean'`
- `'undefined'`
- `'object'`
- `'function'`
- `'symbol'`
- `'bigint'`

### Ejemplo: Validar Entrada de Usuario

```typescript
// ‚ùå Sin type guard - c√≥digo inseguro
function display(input: string | number | boolean) {
  console.log(input.toString()); // ¬øy si no tiene toString()?
}

// ‚úÖ Con type guards
function display(input: string | number | boolean) {
  if (typeof input === 'string') {
    console.log(`Texto: ${input.length} caracteres`);
  } else if (typeof input === 'number') {
    console.log(`N√∫mero: ${input.toFixed(2)}`);
  } else {
    console.log(`Boolean: ${input ? 'Verdadero' : 'Falso'}`);
  }
}

display('hola'); // Texto: 4 caracteres
display(42); // N√∫mero: 42.00
display(true); // Boolean: Verdadero
```

---

## instanceof: Preguntar si es Instancia de Clase {#instanceof}

Usa `instanceof` para preguntar: ¬øeres una instancia de esa clase?

```typescript
// Ejemplo b√°sico
class User {
  constructor(public name: string) {}
}

class Product {
  constructor(public name: string) {}
}

// ‚ùå Sin type guard - no sabemos qu√© es
function process(item: User | Product) {
  // ¬øqu√© m√©todos tiene?
}

// ‚úÖ Con instanceof
function process(item: User | Product) {
  if (item instanceof User) {
    // TypeScript sabe: item es User
    console.log(`Usuario: ${item.name}`);
  } else {
    // TypeScript sabe: item es Product
    console.log(`Producto: ${item.name}`);
  }
}

process(new User('Juan')); // Usuario: Juan
process(new Product('Mouse')); // Producto: Mouse
```

### Ejemplo Real: Manejar Errores

```typescript
// Cuando atrapas un error, ¬øqu√© tipo es?
async function downloadData(url: string) {
  try {
    const response = await fetch(url);
    return response.json();
  } catch (error) {
    // ‚ùå Sin type guard - error podr√≠a ser cualquier cosa
    // console.log(error.message); // ¬øError tiene .message?

    // ‚úÖ Con type guard
    if (error instanceof Error) {
      // Aqu√≠ SABEMOS que es Error
      console.log(`Fallo: ${error.message}`); // ‚úÖ .message existe
    } else {
      // Podr√≠a ser algo completamente diferente
      console.log('Error desconocido:', error);
    }
  }
}
```

---

## Custom Type Guards: Funciones Propias {#custom}

A veces necesitas una pregunta m√°s compleja. Creas tu propia funci√≥n de type guard.

### Ejemplo B√°sico

```typescript
// Definir dos interfaces
interface Cat {
  type: 'cat';
  meow: () => void;
}

interface Dog {
  type: 'dog';
  bark: () => void;
}

type Animal = Cat | Dog;

// ‚ùå Sin type guard personalizado
function makeSound(animal: Animal) {
  // if (animal.type === 'cat') animal.meow(); // Error
  // No sabemos si animal.meow existe
}

// ‚úÖ Type guard personalizado: 'value is Type'
function isCat(animal: Animal): animal is Cat {
  return animal.type === 'cat';
}

function isDog(animal: Animal): animal is Dog {
  return animal.type === 'dog';
}

// Ahora funciona!
function makeSound(animal: Animal) {
  if (isCat(animal)) {
    // TypeScript sabe: animal es Cat
    animal.meow(); // ‚úÖ OK
  } else {
    // TypeScript sabe: animal es Dog
    animal.bark(); // ‚úÖ OK
  }
}
```

### Ejemplo Real: Detectar Tipo de DTO en NestJS

```typescript
// Dos tipos de DTOs
interface CreateUserDto {
  name: string;
  email: string;
  password: string;
}

interface CreateProductDto {
  name: string;
  price: number;
  stock: number;
}

type CreateAnyDto = CreateUserDto | CreateProductDto;

// ‚ùå Sin type guard - ¬øc√≥mo s√© cu√°l es?
function create(dto: CreateAnyDto) {
  // if (dto.email) { } // ¬øexiste email?
}

// ‚úÖ Con type guard personalizado
function isCreateUserDto(dto: CreateAnyDto): dto is CreateUserDto {
  return 'email' in dto && 'password' in dto;
}

function isCreateProductDto(dto: CreateAnyDto): dto is CreateProductDto {
  return 'price' in dto && 'stock' in dto;
}

// Ahora sabemos exactamente qu√© propiedades tiene
@Injectable()
export class EntityService {
  create(dto: CreateAnyDto) {
    if (isCreateUserDto(dto)) {
      // dto tiene: name, email, password
      return this.createUser({
        name: dto.name,
        email: dto.email,
        password: dto.password,
      });
    }

    if (isCreateProductDto(dto)) {
      // dto tiene: name, price, stock
      return this.createProduct({
        name: dto.name,
        price: dto.price,
        stock: dto.stock,
      });
    }
  }
}
```

---

## Discriminated Unions: Propiedades Marcadas {#discriminated}

Una t√©cnica super √∫til: marcar tus tipos con una propiedad com√∫n que los identifique.

```typescript
// ‚ùå Sin discriminante - tipos confusos
interface Circle {
  radius: number;
}

interface Rectangle {
  width: number;
  height: number;
}

type Shape = Circle | Rectangle;

// ¬øC√≥mo s√© cu√°l es cu√°l si veo { radius: 5, width: 10 }?

// ‚úÖ Con discriminante - tipos claros
interface Circle {
  type: 'circle'; // ‚Üê Discriminante
  radius: number;
}

interface Rectangle {
  type: 'rectangle'; // ‚Üê Discriminante
  width: number;
  height: number;
}

interface Triangle {
  type: 'triangle'; // ‚Üê Discriminante
  base: number;
  height: number;
}

type Shape = Circle | Rectangle | Triangle;

// Ahora es obvio cu√°l es cu√°l
function calculateArea(shape: Shape): number {
  switch (shape.type) {
    case 'circle':
      // TypeScript sabe: shape es Circle, tiene .radius
      return Math.PI * shape.radius ** 2; // ‚úÖ

    case 'rectangle':
      // TypeScript sabe: shape es Rectangle, tiene .width y .height
      return shape.width * shape.height; // ‚úÖ

    case 'triangle':
      // TypeScript sabe: shape es Triangle, tiene .base y .height
      return (shape.base * shape.height) / 2; // ‚úÖ

    default:
      // Si olvidamos un caso, TypeScript te lo dice
      const _exhaustive: never = shape;
      throw new Error(`Unknown shape`);
  }
}

calculateArea({ type: 'circle', radius: 5 }); // 78.54
calculateArea({ type: 'rectangle', width: 4, height: 6 }); // 24
calculateArea({ type: 'triangle', base: 3, height: 4 }); // 6
```

### Ejemplo Real: Eventos Tipados en NestJS

```typescript
// Sin discriminante - confuso
// interface Event { payload: any; }

// Con discriminante - perfecto
interface UserCreatedEvent {
  type: 'user.created'; // ‚Üê Marca qu√© evento es
  payload: { userId: string; email: string };
}

interface UserUpdatedEvent {
  type: 'user.updated'; // ‚Üê Marca qu√© evento es
  payload: { userId: string; changes: Record<string, any> };
}

interface UserDeletedEvent {
  type: 'user.deleted'; // ‚Üê Marca qu√© evento es
  payload: { userId: string };
}

type UserEvent =
  | UserCreatedEvent
  | UserUpdatedEvent
  | UserDeletedEvent;

@Injectable()
export class UserEventHandler {
  handle(event: UserEvent) {
    switch (event.type) {
      case 'user.created':
        console.log(`‚úÖ Usuario creado: ${event.payload.email}`);
        // event.payload es { userId, email }
        break;

      case 'user.updated':
        console.log(`‚úèÔ∏è Usuario actualizado: ${event.payload.userId}`);
        // event.payload es { userId, changes }
        break;

      case 'user.deleted':
        console.log(`üóëÔ∏è Usuario eliminado: ${event.payload.userId}`);
        // event.payload es { userId }
        break;
    }
  }
}
```

---

## El Operador 'in': ¬øExiste esta Propiedad? {#in}

Usa `in` para preguntar: ¬øeste objeto tiene esta propiedad?

```typescript
// Ejemplo b√°sico
interface SuccessResponse {
  data: string; // √âxito
  status: 'success';
}

interface ErrorResponse {
  error: string; // Error
  status: 'error';
}

type ApiResponse = SuccessResponse | ErrorResponse;

// ‚ùå Sin 'in' - no sabemos cu√°l tiene qu√©
function handle(resp: ApiResponse) {
  // if (resp.data) { } // ¬ødata existe?
}

// ‚úÖ Con 'in'
function handle(resp: ApiResponse) {
  if ('data' in resp) {
    // TypeScript sabe: resp es SuccessResponse
    console.log('‚úÖ Success:', resp.data); // ‚úÖ .data existe
  } else {
    // TypeScript sabe: resp es ErrorResponse
    console.log('‚ùå Error:', resp.error); // ‚úÖ .error existe
  }
}

handle({ data: 'resultado', status: 'success' }); // ‚úÖ Success: resultado
handle({ error: 'Not found', status: 'error' }); // ‚ùå Error: Not found
```

---

## Assertion Functions: Asegurar o Explotar {#assertions}

A veces dices: "si esto no es verdad, ¬°explota!". Eso es una `assertion function`.

```typescript
// ‚ùå Sin assertion
function process(value: unknown) {
  const text = value as string; // Asumir sin verificar
  console.log(text.toUpperCase()); // Podr√≠a fallar en runtime
}

// ‚úÖ Con assertion
function assertIsString(value: unknown): asserts value is string {
  if (typeof value !== 'string') {
    throw new Error('Not a string!');
  }
}

function process(value: unknown) {
  assertIsString(value); // Si no es string, ¬°explota aqu√≠!
  // Despu√©s de esto, TypeScript SABE que es string
  console.log(value.toUpperCase()); // ‚úÖ Seguro
}

process('hola'); // HOLA
process(123); // ¬°Error: Not a string!
```

### Uso Com√∫n: Validar Entidades

```typescript
interface User {
  id: string;
  name: string;
}

// Verificar que el objeto desconocido es realmente un User
function assertIsUser(obj: unknown): asserts obj is User {
  if (
    typeof obj !== 'object' ||
    obj === null ||
    !('id' in obj) ||
    !('name' in obj)
  ) {
    throw new Error('Not a valid User');
  }
}

async function updateUser(data: unknown) {
  assertIsUser(data); // Si no es v√°lido, ¬°error!
  
  // Ahora TypeScript SABE que data es User
  await repository.update(data.id, {
    name: data.name,
  });
}
```

---

## Null/Undefined: Limpiar Tipos Opcionables {#nullable}

A veces quieres eliminar `null` o `undefined` de un tipo.

```typescript
// Funciones √∫tiles
function isNotNull<T>(value: T | null): value is T {
  return value !== null;
}

function isNotUndefined<T>(value: T | undefined): value is T {
  return value !== undefined;
}

function isDefined<T>(value: T | null | undefined): value is T {
  return value != null; // Chequea null Y undefined
}

// Uso: Limpiar arrays
const values: (string | null | undefined)[] = [
  'a',
  null,
  'b',
  undefined,
  'c',
];

const noEmpty = values.filter(isDefined);
// Resultado: ['a', 'b', 'c']
// TypeScript sabe que es string[] (sin null/undefined)
```

### Ejemplo Real: Navegar Objetos Profundos

```typescript
interface User {
  id: string;
  profile?: {
    avatar?: string;
    bio?: string;
  };
}

// ‚ùå Sin type guards - peligroso
function getAvatar(user: User): string {
  return user.profile.avatar; // ¬øqu√© si profile es undefined?
}

// ‚úÖ Con type guards
function getAvatar(user: User): string | null {
  if (isDefined(user.profile) && isDefined(user.profile.avatar)) {
    return user.profile.avatar; // ‚úÖ Es string
  }
  return null;
}

const user: User = {
  id: '1',
  profile: {
    avatar: 'https://...',
    bio: 'Hello',
  },
};

console.log(getAvatar(user)); // 'https://...'
```

---

## Casos Reales en NestJS {#nestjs}

### 1. Validar DTOs con Type Guards

```typescript
interface CreateUserDto {
  name: string;
  email: string;
  age: number;
}

@Injectable()
export class ValidationService {
  private isValidEmail(email: unknown): email is string {
    return (
      typeof email === 'string' &&
      /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
    );
  }

  private isValidAge(age: unknown): age is number {
    return typeof age === 'number' && age > 0 && age < 150;
  }

  validateDTO(data: unknown): data is CreateUserDto {
    if (typeof data !== 'object' || data === null) {
      return false;
    }

    const obj = data as any;

    return (
      typeof obj.name === 'string' &&
      this.isValidEmail(obj.email) &&
      this.isValidAge(obj.age)
    );
  }
}
```

### 2. Result Type: √âxito o Error

```typescript
type Success<T> = { success: true; data: T };
type Failure<E> = { success: false; error: E };
type Result<T, E = Error> = Success<T> | Failure<E>;

function isSuccess<T, E>(result: Result<T, E>): result is Success<T> {
  return result.success === true;
}

function isFailure<T, E>(result: Result<T, E>): result is Failure<E> {
  return result.success === false;
}

@Injectable()
export class UserService {
  async findUser(id: string): Promise<Result<User, string>> {
    const user = await this.repository.findOne({ where: { id } });

    if (!user) {
      return { success: false, error: 'User not found' };
    }

    return { success: true, data: user };
  }
}

// Uso
const result = await userService.findUser('123');

if (isSuccess(result)) {
  console.log('‚úÖ', result.data.name); // Type: User
} else {
  console.error('‚ùå', result.error); // Type: string
}
```

### 3. Estados Async: Loading, Success, Error

```typescript
interface LoadingState {
  status: 'loading';
}

interface SuccessState<T> {
  status: 'success';
  data: T;
}

interface ErrorState {
  status: 'error';
  error: string;
}

type AsyncState<T> = LoadingState | SuccessState<T> | ErrorState;

function renderUser(state: AsyncState<User>) {
  switch (state.status) {
    case 'loading':
      return '‚è≥ Loading...';

    case 'success':
      // state.data es User
      return `üë§ ${state.data.name}`;

    case 'error':
      // state.error es string
      return `‚ö†Ô∏è ${state.error}`;
  }
}
```

---

## Resumen: Lo Que Aprendiste {#resumen}

- ‚úÖ **typeof:** Preguntar el tipo primitivo de un valor (`string`, `number`, `boolean`, etc.)
- ‚úÖ **instanceof:** Verificar si un objeto es instancia de una clase espec√≠fica
- ‚úÖ **Custom Type Guards:** Funciones propias con predicado `is` para l√≥gica compleja
- ‚úÖ **Discriminated Unions:** Usar propiedades discriminantes (`type`, `status`) para pattern matching
- ‚úÖ **Operador 'in':** Preguntar si una propiedad existe en un objeto sin errores
- ‚úÖ **Assertion Functions:** Funciones que afirman un tipo o explotan si es falso
- ‚úÖ **Null/Undefined Guards:** Limpiar tipos opcionables con checks seguros
- ‚úÖ **NestJS Validaci√≥n:** Usar `@IsString()`, `@IsEmail()` para validar DTOs
- ‚úÖ **Result Types:** Manejar `Success<T> | Error<E>` sin excepciones con type guards
- ‚úÖ **Estados Async:** Type guards para `Loading | Success | Error` en componentes/APIs

**Lo importante:** Type Guards = **seguridad sin excepciones**. Pregunt√°s el tipo primero, lo asegur√°s tipado, y luego usas con confianza. Es la raz√≥n por la que TypeScript es mucho m√°s seguro que JavaScript.

---

## üìã Checklist: ¬øEntendiste Type Guards?

- ‚úÖ Entiendo `typeof` para primitivos: `typeof x === 'string'`, `typeof x === 'number'`
- ‚úÖ Entiendo `instanceof` para clases: `object instanceof MyClass`, `error instanceof ValidationError`
- ‚úÖ Puedo escribir custom type guards con predicado `is`: `function isCat(value: unknown): value is Cat`
- ‚úÖ Entiendo discriminated unions: `interface A { type: 'a'; data: number }` + switch en `union.type`
- ‚úÖ Entiendo el operador `in`: `if ('property' in object) { /* object.property existe */ }`
- ‚úÖ Puedo escribir assertion functions: `function assertIsString(value: unknown): asserts value is string`
- ‚úÖ Puedo limpiar null/undefined: `if (value !== null && value !== undefined) { /* value est√° definido */ }`
- ‚úÖ Puedo usar type guards en NestJS: `@IsString()`, `@IsEmail()`, `@ValidateNested()`
- ‚úÖ Puedo usar Result types: `type Result<T> = {success: true; data: T} | {success: false; error: string}`
- ‚úÖ Puedo manejar estados async con discriminator: `status: 'loading' | 'success' | 'error'`
- ‚úÖ Entiendo que type guards son **runtime checks** que TypeScript entiende est√°ticamente

**üéØ Pr√≥ximo paso:** [8. Discriminated Unions: Pattern Matching Avanzado](./8.Discriminated-Unions[TypeScript].md)

**üéØ Recuerda:** Type Guards transforman `unknown` en `known`. Son tu aliado para escribir c√≥digo seguro sin `any` ni excepciones sorpresa.