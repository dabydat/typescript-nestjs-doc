# ğŸ“ Template Literal Types: Strings DinÃ¡micos y Type-Safe

DespuÃ©s de dominar **Mapped Types**, ahora toca **Template Literal Types**: el superpoder para crear tipos de string dinÃ¡micos, altamente especÃ­ficos y completamente type-safe.

Imagina que necesitas crear rutas API, nombres de eventos, o headers HTTP que sean validados en tiempo de compilaciÃ³n. Template literal types hacen exactamente eso. **Son template strings, pero para tipos.** âœ¨

---

## ğŸ“š Ãndice de Contenidos

1. **[Â¿QuÃ© Son Template Literal Types?](#quÃ©-son-template-literal-types)** - Conceptos fundamentales
2. **[Sintaxis: `string ${Type} string`](#sintaxis-string-type-string)** - Creando strings dinÃ¡micos
3. **[Unions Generan Combinaciones](#unions-generan-combinaciones)** - Producto cartesiano
4. **[Intrinsic String Types](#intrinsic-string-types)** - Uppercase, Lowercase, Capitalize
5. **[Event Names Type-Safe](#event-names-type-safe)** - Patrones 'entity.action'
6. **[Route Definitions](#route-definitions)** - API versioning y CRUD
7. **[Query Builders Type-Safe](#query-builders-type-safe)** - Field operators
8. **[HTTP Headers & CSS Values](#http-headers--css-values)** - ValidaciÃ³n de standards
9. **[Environment Variables](#environment-variables)** - Config type-safe
10. **[Pattern Matching & Extraction](#pattern-matching--extraction)** - `infer` con template literals
11. **[Resumen](#resumen-lo-que-aprendiste)** - Recap
12. **[Checklist](#-checklist-Â¿entendiste-template-literal-types)** - ValidaciÃ³n

---

## Â¿QuÃ© Son Template Literal Types?

Un **template literal type** es un tipo que usa sintaxis de template strings para crear tipos de string altamente especÃ­ficos.

Sintaxis base:

$$\`\text{string} \$\{Type\} \text{string}\`$$

**Lo clave:** Construyes tipos como construyes strings, pero validados completamente. Â¡No mÃ¡s "cualquier string"!

**Ejemplo mental:**
```typescript
// Sin template literals: "cualquier string" âŒ
type Route = string;
// '/users', '/invalid', 'xyz'... TODO VALE

// Con template literals: strings especÃ­ficos âœ…
type Route = '/users' | '/products' | '/orders';
// SOLO esos, nada mÃ¡s
```

---

## Sintaxis: `string ${Type} string`

**Â¿CÃ³mo funciona?**

```typescript
// Tipo simple
type World = 'world';
type Greeting = `hello ${World}`;
// Type: 'hello world' âœ…

// Con unions: genera TODAS las combinaciones
type Color = 'red' | 'blue' | 'green';
type Button = `${Color}-button`;
// Type: 'red-button' | 'blue-button' | 'green-button' âœ…
```

### Â¿Por QuÃ© Importa?

Sin template literals:
```typescript
// âŒ Manual y frÃ¡gil
type ButtonVariant = 'red-button' | 'blue-button' | 'green-button';
// Si agrego color, debo actualizar esto
```

Con template literals:
```typescript
// âœ… AutomÃ¡tico y escalable
type ButtonVariant = `${Color}-button`;
// Agrego color a la union, Â¡todo se genera automÃ¡ticamente!
```

---

## Unions Generan Combinaciones

Cuando usas unions en template literals, TypeScript genera el **producto cartesiano** (todas las combinaciones).

```typescript
type Size = 'small' | 'medium' | 'large';
type Color = 'red' | 'blue' | 'green';

// MÃºltiples placeholders = combinaciones
type ButtonVariant = `${Size}-${Color}-button`;
// Type: 'small-red-button' | 'small-blue-button' | ... (9 combinaciones)

// Con 3 unions: 3 Ã— 3 Ã— 1 = 9 tipos diferentes âœ…
```

### Caso Real: Nombres de MÃ©todos

```typescript
type Method = 'GET' | 'POST' | 'PUT' | 'DELETE';
type Resource = 'users' | 'products' | 'orders';

type ApiMethod = `${Lowercase<Method>}${Capitalize<Resource>}`;
// Type:
//   | 'getUsers' | 'getProducts' | 'getOrders'
//   | 'postUsers' | 'postProducts' | 'postOrders'
//   | 'putUsers' | 'putProducts' | 'putOrders'
//   | 'deleteUsers' | 'deleteProducts' | 'deleteOrders' âœ…
```

---

## Intrinsic String Types

TypeScript proporciona tipos built-in para manipular strings:

- `Uppercase<T>`: Convertir a MAYÃšSCULAS
- `Lowercase<T>`: Convertir a minÃºsculas
- `Capitalize<T>`: Primera letra mayÃºscula
- `Uncapitalize<T>`: Primera letra minÃºscula

```typescript
type Upper = Uppercase<'hello'>;
// Type: 'HELLO' âœ…

type Lower = Lowercase<'HELLO'>;
// Type: 'hello' âœ…

type Cap = Capitalize<'hello'>;
// Type: 'Hello' âœ…

type Uncap = Uncapitalize<'Hello'>;
// Type: 'hello' âœ…
```

### Caso Real: HTTP Handlers

```typescript
type HTTPMethod = 'get' | 'post' | 'put' | 'delete';

// Generar nombres de handlers automÃ¡ticamente
type HandlerName<M extends HTTPMethod> = `handle${Capitalize<M>}Request`;

type GetHandler = HandlerName<'get'>;
// Type: 'handleGetRequest' âœ…

type PostHandler = HandlerName<'post'>;
// Type: 'handlePostRequest' âœ…
```

---

## Event Names Type-Safe

PatrÃ³n comÃºn: `entity.action` para eventos de dominio.

```typescript
type DomainEntity = 'user' | 'order' | 'product';
type DomainAction = 'created' | 'updated' | 'deleted';

type EventName<E extends DomainEntity, A extends DomainAction> = `${E}.${A}`;

type UserCreated = EventName<'user', 'created'>;
// Type: 'user.created' âœ…

// Generar TODOS los eventos posibles
type AllEvents = EventName<DomainEntity, DomainAction>;
// Type:
//   | 'user.created' | 'user.updated' | 'user.deleted'
//   | 'order.created' | 'order.updated' | 'order.deleted'
//   | 'product.created' | 'product.updated' | 'product.deleted' âœ…
```

### Caso Real: Event Emitter Type-Safe

```typescript
interface EventPayloads {
  'user.created': { userId: string; email: string };
  'user.updated': { userId: string; changes: Record<string, any> };
  'order.created': { orderId: string; total: number };
}

class TypeSafeEventEmitter {
  emit<E extends keyof EventPayloads>(
    event: E,
    payload: EventPayloads[E],
  ): void {
    console.log(`Event: ${event}`, payload);
  }

  on<E extends keyof EventPayloads>(
    event: E,
    handler: (payload: EventPayloads[E]) => void,
  ): void {
    // Register handler
  }
}

const emitter = new TypeSafeEventEmitter();

// Type-safe emit: TypeScript valida el payload
emitter.emit('user.created', {
  userId: '123',
  email: 'john@example.com',
}); // âœ…

// emitter.emit('user.created', { userId: '123' }); 
// âŒ Error: falta email (type-safe!)

// Type-safe listener: tipos del payload inferidos
emitter.on('order.created', (payload) => {
  console.log(payload.orderId); // Type: string âœ…
  console.log(payload.total); // Type: number âœ…
});
```

---

## Route Definitions

Rutas API type-safe con versionado y validaciÃ³n.

```typescript
// Rutas CRUD bÃ¡sicas
type Entity = 'users' | 'products' | 'orders';
type Action = 'list' | 'detail' | 'create' | 'update' | 'delete';

type RestRoute<E extends Entity, A extends Action> = A extends 'list'
  ? `/${E}`
  : A extends 'create'
  ? `/${E}`
  : `/${E}/:id`;

type UserList = RestRoute<'users', 'list'>;
// Type: '/users' âœ…

type UserDetail = RestRoute<'users', 'detail'>;
// Type: '/users/:id' âœ…
```

### API Versioning Type-Safe

```typescript
type ApiVersion = 1 | 2 | 3;
type VersionedRoute<V extends ApiVersion, Path extends string> = `/api/v${V}${Path}`;

type UserRouteV1 = VersionedRoute<1, '/users'>;
// Type: '/api/v1/users' âœ…

type UserRouteV2 = VersionedRoute<2, '/users'>;
// Type: '/api/v2/users' âœ…

// En NestJS Controller
@Controller()
export class VersionedController {
  @Get('/api/v1/users' as VersionedRoute<1, '/users'>)
  getUsersV1() {
    // V1 implementation
  }

  @Get('/api/v2/users' as VersionedRoute<2, '/users'>)
  getUsersV2() {
    // V2 implementation - cambios de schema, etc
  }
}
```

---

## Query Builders Type-Safe

Operadores de query con validaciÃ³n por tipo de campo.

```typescript
type Operator = 'eq' | 'ne' | 'gt' | 'lt' | 'gte' | 'lte' | 'like';

type FieldOperator<F extends string, O extends Operator> = `${F}_${O}`;

type UserAgeGt = FieldOperator<'age', 'gt'>;
// Type: 'age_gt' âœ…

type UserNameLike = FieldOperator<'name', 'like'>;
// Type: 'name_like' âœ…

// Query params type-safe
interface User {
  id: string;
  name: string;
  email: string;
  age: number;
  isActive: boolean;
}

type QueryOperators<T> = {
  [K in keyof T as K extends string ? `${K}_${Operator}` : never]?: T[K] extends string
    ? string
    : T[K] extends number
    ? number
    : T[K] extends boolean
    ? boolean
    : never;
};

type UserQuery = QueryOperators<User>;
// Type: {
//   id_eq?: string;
//   name_like?: string;
//   age_gt?: number;
//   age_lt?: number;
//   isActive_eq?: boolean;
//   ... (todas las combinaciones type-safe)
// } âœ…

// Uso: type-safe por tipo de field
const query: Partial<UserQuery> = {
  age_gt: 18, // âœ… number
  name_like: '%John%', // âœ… string
  // age_gt: 'invalid', // âŒ Error: debe ser number
};
```

---

## HTTP Headers & CSS Values

ValidaciÃ³n de standards web a nivel de tipos.

### HTTP Headers

```typescript
type StandardHeader =
  | 'content-type'
  | 'authorization'
  | 'accept'
  | 'user-agent';

// Headers personalizados con prefijo
type CustomHeader<Prefix extends string> = `x-${Lowercase<Prefix>}-${string}`;

type AppHeader = CustomHeader<'app'>;
// Type: `x-app-${string}` âœ…

// Cualquier header vÃ¡lido
type AllHeaders = StandardHeader | CustomHeader<'app' | 'api'>;

const headers: Record<string, string> = {
  'content-type': 'application/json',
  'x-app-version': '1.0.0',
};

// Type-safe header access
const contentType = headers['content-type']; // âœ… conocido
const customHeader = headers['x-app-version']; // âœ… vÃ¡lido por patrÃ³n
```

### CSS Values

```typescript
type CSSUnit = 'px' | 'em' | 'rem' | '%' | 'vh' | 'vw';
type CSSValue<U extends CSSUnit> = `${number}${U}`;

type PixelValue = CSSValue<'px'>;
// Type: `${number}px` âœ…

type RemValue = CSSValue<'rem'>;
// Type: `${number}rem` âœ…

// ValidaciÃ³n en compilaciÃ³n
const width: PixelValue = '100px'; // âœ…
const height: RemValue = '2rem'; // âœ…
// const invalid: PixelValue = '100rem'; // âŒ Error: no es px
```

---

## Environment Variables

Config type-safe con variables de entorno prefijadas.

```typescript
type EnvPrefix = 'APP' | 'DB' | 'REDIS' | 'AWS';
type EnvVariable<P extends EnvPrefix, Name extends string> = `${P}_${Uppercase<Name>}`;

type AppPort = EnvVariable<'APP', 'port'>;
// Type: 'APP_PORT' âœ…

type DbHost = EnvVariable<'DB', 'host'>;
// Type: 'DB_HOST' âœ…

type RedisUrl = EnvVariable<'REDIS', 'url'>;
// Type: 'REDIS_URL' âœ…

// Config type-safe con env vars
interface EnvConfig {
  [EnvVariable<'APP', 'port'>]: number;
  [EnvVariable<'APP', 'name'>]: string;
  [EnvVariable<'DB', 'host'>]: string;
  [EnvVariable<'DB', 'port'>]: number;
  [EnvVariable<'REDIS', 'url'>]: string;
}

// Usar: nombres garantizados
const config: EnvConfig = {
  APP_PORT: 3000, // âœ…
  APP_NAME: 'My App', // âœ…
  DB_HOST: 'localhost', // âœ…
  DB_PORT: 5432, // âœ…
  REDIS_URL: 'redis://localhost:6379', // âœ…
  // INVALID_KEY: '', // âŒ Error: no es env var vÃ¡lida
};
```

---

## Pattern Matching & Extraction

Usar `infer` con template literals para extraer partes de strings.

```typescript
// Extraer versiÃ³n de ruta
type ExtractVersion<T extends string> =
  T extends `/api/v${infer V extends number}/${string}` ? V : never;

type V1 = ExtractVersion<'/api/v1/users'>;
// Type: 1 âœ…

type V2 = ExtractVersion<'/api/v2/products'>;
// Type: 2 âœ…

type NoVersion = ExtractVersion<'/users'>;
// Type: never âœ…

// Extraer entity de ruta CRUD
type ExtractEntity<T extends string> =
  T extends `/${infer E}` | `/${infer E}/:id` ? E : never;

type Entity1 = ExtractEntity<'/users'>;
// Type: 'users' âœ…

type Entity2 = ExtractEntity<'/products/:id'>;
// Type: 'products' âœ…

// Parsear query params
type ParseQueryParam<T extends string> =
  T extends `${infer Key}=${infer Value}` ? { [K in Key]: Value } : never;

type Parsed = ParseQueryParam<'name=John'>;
// Type: { name: 'John' } âœ…
```

---

## Resumen: Lo Que Aprendiste

- âœ… **Sintaxis:** `` `string ${Type} string` `` (template strings para tipos)
- âœ… **Unions:** Generan combinaciones automÃ¡ticamente (producto cartesiano)
- âœ… **Intrinsic Types:** Uppercase, Lowercase, Capitalize, Uncapitalize
- âœ… **Event Names:** PatrÃ³n `entity.action` con validaciÃ³n
- âœ… **Routes:** API versioning, CRUD patterns, type-safe
- âœ… **Query Builders:** Operadores tipo-seguros por tipo de field
- âœ… **Headers & CSS:** ValidaciÃ³n de standards web
- âœ… **Environment Variables:** Config con prefijos garantizados
- âœ… **Pattern Extraction:** `infer` + template literals para parsing
- âœ… **Real-World:** Event emitters, routers, validators â€” todo generado

**Lo importante:** Template literal types = **strings como tipos de primera clase**. No son "cualquier string", son strings especÃ­ficos, validados, escalables. Â¡La mÃ¡xima especificidad sin sacrificar flexibilidad! ğŸ¯

---

## ğŸ“‹ Checklist: Â¿Entendiste Template Literal Types? Tengamos presente lo siguiente:

- âœ… Sintaxis: `` `string ${Type} string` ``
- âœ… Unions generan producto cartesiano
- âœ… Intrinsic string types: Uppercase, Lowercase, Capitalize
- âœ… Event names type-safe: `entity.action` pattern
- âœ… Route definitions: versioning, CRUD, params
- âœ… Query builders: field operators type-safe
- âœ… HTTP headers: standard + custom con prefijos
- âœ… CSS values: units y validaciÃ³n
- âœ… Environment variables: prefijos y nombres garantizados
- âœ… Pattern extraction: `infer` con template literals

**ğŸ¯ PrÃ³ximo paso:** [6ï¸âƒ£ Decorators Deep Dive](./6.Decorators[TypeScript].md) â€” Metadata y runtime reflection en NestJS.

**ğŸ¯ Recuerda:** Template literal types convierten strings en ciudadanos de primera clase del sistema de tipos. Ãšsalos para mÃ¡xima seguridad y escalabilidad.