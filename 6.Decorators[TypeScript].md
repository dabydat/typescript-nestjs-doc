# üé® Decorators: Herramientas que "Anotam" tu C√≥digo

## Introducci√≥n: ¬øQu√© es un Decorator?

Imagina que tienes un m√©todo en tu c√≥digo. Un **decorator** es como una **nota adhesiva** que colocas encima de ese m√©todo para decirle "hey, antes de que corras, hazme un favor".

```typescript
// ‚ùå Sin decorator - c√≥digo aburrido
class User {
  sayHello() {
    console.log('Hola!');
  }
}

// ‚úÖ Con decorator - c√≥digo con superpoderes
@BumpText // Una nota que dice: "amplifica lo que hago"
class User {
  sayHello() {
    console.log('Hola!');
  }
}
```

**El decorator es simplemente una funci√≥n que modifica tu c√≥digo sin que tengas que cambiarlo manualmente.** Eso es todo. No es magia, es automatizaci√≥n.

NestJS usa decorators para hacer que el c√≥digo se auto-configure autom√°ticamente. Por eso ves `@Injectable()`, `@Get()`, `@Body()` por todos lados.

---

## üìã √çndice de Contenidos

1. [Analog√≠a: Decorators como Wrapping de Funciones](#analog√≠a-decorators-como-wrapping-de-funciones)
2. [Class Decorators: Modificar Constructores](#class-decorators-modificar-constructores)
3. [Method Decorators: Envolver M√©todos](#method-decorators-envolver-m√©todos)
4. [Property Decorators: Metadata en Propiedades](#property-decorators-metadata-en-propiedades)
5. [Parameter Decorators: Informaci√≥n de Par√°metros](#parameter-decorators-informaci√≥n-de-par√°metros)
6. [Reflect-Metadata: La API de Metadata en Runtime](#reflect-metadata-la-api-de-metadata-en-runtime)
7. [Metadata Autom√°tica: design:type, design:paramtypes](#metadata-autom√°tica-designtype-designparamtypes)
8. [Decorator Factories: Decorators con Par√°metros](#decorator-factories-decorators-con-par√°metros)
9. [Composici√≥n: M√∫ltiples Decorators](#composici√≥n-m√∫ltiples-decorators)
10. [Casos Reales: Decorators en NestJS](#casos-reales-decorators-en-nestjs)
11. [Resumen y Checklist](#resumen-y-checklist)

---

## Analog√≠a: Decorators como Wrapping de Funciones

Imagina que tienes un m√©todo `calculateTotal()`. Sin decorators:

```typescript
// ‚ùå Sin decorators - hacerlo manualmente
class OrderService {
  calculateTotal(items: any[]): number {
    console.log('Calculating...');
    const total = items.reduce((sum, item) => sum + item.price, 0);
    console.log('Result:', total);
    return total;
  }
}
```

Repetir logging en cada m√©todo es tedioso. Los decorators permiten **automatizar esto**:

```typescript
// ‚úÖ Con decorators - una sola vez
function Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  
  descriptor.value = function (...args: any[]) {
    console.log(`Calling ${propertyKey}`);
    const result = originalMethod.apply(this, args);
    console.log(`Result:`, result);
    return result;
  };
  
  return descriptor;
}

class OrderService {
  @Log
  calculateTotal(items: any[]): number {
    return items.reduce((sum, item) => sum + item.price, 0);
  }
}
```

**¬°Eso es un decorator!** Una funci√≥n que modifica otra funci√≥n sin tocar su c√≥digo.

---

## Class Decorators: Modificar Constructores

### ¬øC√≥mo funciona?

Un class decorator recibe el constructor de la clase y puede modificarlo o reemplazarlo:

```typescript
type ClassDecorator = <TFunction extends Function>(
  target: TFunction,
) => TFunction | void;
```

### Ejemplo 1: Decorator Simple

```typescript
// ‚ùå Sin decorator
class MyClass {
  name = 'John';
}
// Se puede modificar libremente
MyClass.name = 'modified'; // ‚úÖ Funciona

// ‚úÖ Con decorator @Sealed
function Sealed(constructor: Function) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}

@Sealed
class MyClass {
  name = 'John';
}

MyClass.name = 'modified'; // ‚ùå Error! La clase est√° sellada
```

### Ejemplo 2: Agregar Metadata a la Clase

```typescript
function Entity(tableName: string) {
  return function <T extends { new (...args: any[]): {} }>(constructor: T) {
    // Guardar metadata de base de datos
    Reflect.defineMetadata('tableName', tableName, constructor);
    
    return class extends constructor {
      tableName = tableName;
    };
  };
}

// ‚úÖ Ahora la clase tiene metadata de tabla
@Entity('users')
class User {
  id: string;
  name: string;
}

// Leer la metadata
const table = Reflect.getMetadata('tableName', User);
console.log(table); // 'users' ‚úÖ
```

### Caso Real: @Injectable() en NestJS

```typescript
// ‚ùå C√≥mo NestJS lo hace internamente
function Injectable(options?: { scope?: 'DEFAULT' | 'REQUEST' | 'TRANSIENT' }) {
  return function <T extends { new (...args: any[]): {} }>(target: T) {
    // Registrar esta clase como inyectable
    Reflect.defineMetadata('injectable', true, target);
    Reflect.defineMetadata('scope', options?.scope || 'DEFAULT', target);
    
    // NestJS se lo marca en su registro interno
    return target;
  };
}

@Injectable({ scope: 'REQUEST' })
class UserService {
  // NestJS sabe: "esta clase es injectable con scope REQUEST"
  // Se crea una nueva instancia para cada request
}
```

---

## Method Decorators: Envolver M√©todos

### ¬øC√≥mo funciona?

Un method decorator recibe tres par√°metros:
- `target`: El prototype de la clase
- `propertyKey`: El nombre del m√©todo
- `descriptor`: El descriptor de la propiedad (acceso al m√©todo original)

```typescript
type MethodDecorator = <T>(
  target: Object,
  propertyKey: string | symbol,
  descriptor: PropertyDescriptor,
) => PropertyDescriptor | void;
```

### Ejemplo 1: Logging Autom√°tico

```typescript
// ‚ùå Sin decorator - logging manual
class Calculator {
  add(a: number, b: number): number {
    console.log(`add(${a}, ${b})`);
    const result = a + b;
    console.log(`Result: ${result}`);
    return result;
  }
}

// ‚úÖ Con decorator @Log
function Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  
  descriptor.value = function (...args: any[]) {
    console.log(`üìû Calling ${propertyKey} with args:`, args);
    const result = originalMethod.apply(this, args);
    console.log(`‚úÖ ${propertyKey} returned:`, result);
    return result;
  };
  
  return descriptor;
}

class Calculator {
  @Log
  add(a: number, b: number): number {
    return a + b;
  }
}

const calc = new Calculator();
calc.add(2, 3);
// Output:
// üìû Calling add with args: [2, 3]
// ‚úÖ add returned: 5
```

### Ejemplo 2: Timeout Autom√°tico

```typescript
// ‚ùå Sin decorator - timeout manual
class ApiService {
  async fetchData(): Promise<any> {
    return Promise.race([
      fetch('https://api.example.com/data'),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Timeout')), 5000)
      ),
    ]);
  }
}

// ‚úÖ Con decorator @Timeout
function Timeout(ms: number) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      return Promise.race([
        originalMethod.apply(this, args),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error('Timeout')), ms)
        ),
      ]);
    };
    
    return descriptor;
  };
}

class ApiService {
  @Timeout(5000) // 5 segundos max
  async fetchData(): Promise<any> {
    return fetch('https://api.example.com/data');
  }
}
```

### Ejemplo 3: Retry Autom√°tico

```typescript
function Retry(maxAttempts: number = 3, delay: number = 1000) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      let lastError: any;
      
      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
          return await originalMethod.apply(this, args);
        } catch (error) {
          lastError = error;
          console.log(`‚ö†Ô∏è Attempt ${attempt} failed, retrying in ${delay}ms...`);
          
          if (attempt < maxAttempts) {
            await new Promise((resolve) => setTimeout(resolve, delay));
          }
        }
      }
      
      throw lastError;
    };
    
    return descriptor;
  };
}

class ExternalService {
  @Retry(3, 2000)
  async callUnstableApi(): Promise<any> {
    // Si falla, reintentar 3 veces con 2 seg entre intentos
    return fetch('https://unstable-api.example.com');
  }
}
```

### Caso Real: @Get() en NestJS

```typescript
// ¬øC√≥mo NestJS registra rutas?
function Get(path: string = '') {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    // Marcar metadata que NestJS leer√° despu√©s
    Reflect.defineMetadata('path', path, target, propertyKey);
    Reflect.defineMetadata('method', 'GET', target, propertyKey);
    
    return descriptor;
  };
}

@Controller('/users')
class UserController {
  @Get('/:id') // Registra: GET /users/:id
  getUser(@Param('id') id: string) {
    // NestJS va a saber que esta funci√≥n maneja GET /users/:id
  }
}
```

---

## Property Decorators: Metadata en Propiedades

### ¬øC√≥mo funciona?

Un property decorator recibe:
- `target`: El prototype de la clase
- `propertyKey`: El nombre de la propiedad

```typescript
type PropertyDecorator = (
  target: Object,
  propertyKey: string | symbol,
) => void;
```

### Ejemplo 1: Validaci√≥n de Columnas DB

```typescript
// ‚ùå Sin decorator - informaci√≥n hardcoded
class User {
  id: string; // ¬øQu√© tipo de columna es?
  name: string;
  email?: string; // ¬øNullable?
}

// ‚úÖ Con decorator @Column
function Column(options?: { type?: string; nullable?: boolean }) {
  return function (target: any, propertyKey: string) {
    Reflect.defineMetadata('column:type', options?.type || 'varchar', target, propertyKey);
    Reflect.defineMetadata('column:nullable', options?.nullable || false, target, propertyKey);
  };
}

class User {
  @Column({ type: 'uuid' })
  id: string;
  
  @Column({ type: 'varchar', nullable: false })
  name: string;
  
  @Column({ type: 'varchar', nullable: true })
  email?: string;
}

// Leer metadata de propiedades
const idType = Reflect.getMetadata('column:type', User.prototype, 'id');
console.log(idType); // 'uuid' ‚úÖ
```

### Ejemplo 2: Validadores Declarativos

```typescript
// ‚ùå Sin decorator - validaci√≥n manual
class CreateUserDto {
  name: string;
  email: string;
}

function validateDto(dto: CreateUserDto) {
  if (typeof dto.name !== 'string') throw new Error('name must be string');
  if (!dto.email.includes('@')) throw new Error('email invalid');
}

// ‚úÖ Con decorators @IsString(), @IsEmail()
function IsString() {
  return function (target: any, propertyKey: string) {
    const validators = Reflect.getMetadata('validators', target, propertyKey) || [];
    validators.push({ type: 'isString' });
    Reflect.defineMetadata('validators', validators, target, propertyKey);
  };
}

function IsEmail() {
  return function (target: any, propertyKey: string) {
    const validators = Reflect.getMetadata('validators', target, propertyKey) || [];
    validators.push({ type: 'isEmail' });
    Reflect.defineMetadata('validators', validators, target, propertyKey);
  };
}

class CreateUserDto {
  @IsString()
  name: string;
  
  @IsEmail()
  email: string;
}

// Un validador general puede leer metadata y validar autom√°ticamente
```

### Caso Real: @Inject() en NestJS

```typescript
function Inject(token: string) {
  return function (target: any, propertyKey: string) {
    // Marcar que esta propiedad necesita inyecci√≥n
    Reflect.defineMetadata('inject:token', token, target, propertyKey);
  };
}

@Injectable()
class MyService {
  @Inject('DATABASE_CONNECTION')
  private connection: any; // NestJS inyectar√° 'DATABASE_CONNECTION' aqu√≠
}
```

---

## Parameter Decorators: Informaci√≥n de Par√°metros

### ¬øC√≥mo funciona?

Un parameter decorator recibe:
- `target`: El prototype de la clase
- `propertyKey`: El nombre del m√©todo
- `parameterIndex`: La posici√≥n del par√°metro (0, 1, 2...)

```typescript
type ParameterDecorator = (
  target: Object,
  propertyKey: string | symbol,
  parameterIndex: number,
) => void;
```

### Ejemplo 1: Validaci√≥n de Par√°metros

```typescript
// ‚ùå Sin decorator - validaci√≥n manual
class UserService {
  createUser(name: string, email: string) {
    if (!name || !email) throw new Error('name and email required');
    // ...
  }
}

// ‚úÖ Con decorator @NotNull
function NotNull(target: any, propertyKey: string, parameterIndex: number) {
  const existingParams = Reflect.getMetadata('notNull', target, propertyKey) || [];
  existingParams.push(parameterIndex);
  Reflect.defineMetadata('notNull', existingParams, target, propertyKey);
}

class UserService {
  createUser(@NotNull name: string, @NotNull email: string) {
    // El runtime puede chequear que par√°metros 0 y 1 no sean null
  }
}
```

### Caso Real: @Body(), @Param(), @Query() en NestJS

```typescript
// ¬øC√≥mo NestJS sabe de d√≥nde extraer datos?

function Body() {
  return function (target: any, methodName: string, parameterIndex: number) {
    Reflect.defineMetadata(`param:${parameterIndex}`, { type: 'body' }, target, methodName);
  };
}

function Param(propertyKey: string) {
  return function (target: any, methodName: string, parameterIndex: number) {
    Reflect.defineMetadata(`param:${parameterIndex}`, { type: 'param', key: propertyKey }, target, methodName);
  };
}

@Controller('/users')
class UserController {
  @Post()
  createUser(@Body() dto: CreateUserDto) {
    // NestJS lee metadata y sabe: "par√°metro 0 viene del body"
  }
  
  @Get('/:id')
  getUser(@Param('id') id: string) {
    // NestJS lee metadata y sabe: "par√°metro 0 viene del path param 'id'"
  }
}

// Sin decorators, NestJS tendr√≠a que adivinar de d√≥nde vienen los datos
```

---

## Reflect-Metadata: La API de Metadata en Runtime

### ¬øQu√© es Reflect-Metadata?

Es una librer√≠a que te permite **guardar y recuperar informaci√≥n** en tiempo de ejecuci√≥n:

```typescript
import 'reflect-metadata';

// Guardar metadata
Reflect.defineMetadata('role', 'admin', UserService);

// Recuperar metadata
const role = Reflect.getMetadata('role', UserService);
console.log(role); // 'admin' ‚úÖ
```

### Guardar Metadata en Diferentes Lugares

```typescript
// En una clase
Reflect.defineMetadata('role', 'admin', UserService);
const role = Reflect.getMetadata('role', UserService);

// En un m√©todo
Reflect.defineMetadata('cache:ttl', 300, UserService.prototype, 'getUser');
const ttl = Reflect.getMetadata('cache:ttl', UserService.prototype, 'getUser');

// En una propiedad
Reflect.defineMetadata('column:type', 'uuid', User.prototype, 'id');
const type = Reflect.getMetadata('column:type', User.prototype, 'id');
```

### ¬øPor Qu√© Importa?

```typescript
// ‚ùå Sin metadata - hardcodear valores
const ROLES = {
  user_service: 'default',
  admin_service: 'admin',
  cache_service: 300,
};

// ‚úÖ Con metadata - declarativo y asociado al c√≥digo
@Injectable()
@Metadata('role', 'admin')
class AdminService {
  @Metadata('cache:ttl', 300)
  getUsers() { }
}

// El c√≥digo que la usa puede leerlo din√°micamente
```

---

## Metadata Autom√°tica: design:type, design:paramtypes

TypeScript puede grabar tipos autom√°ticamente si habilitas `emitDecoratorMetadata` en `tsconfig.json`:

```json
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  }
}
```

Luego TypeScript a√±ade autom√°ticamente 3 tipos de metadata:

### 1. `design:type` - Tipo de la Propiedad

```typescript
class User {
  @Column()
  name: string;
  
  @Column()
  age: number;
}

// TypeScript autom√°ticamente guarda:
const nameType = Reflect.getMetadata('design:type', User.prototype, 'name');
console.log(nameType); // [Function: String] ‚úÖ

const ageType = Reflect.getMetadata('design:type', User.prototype, 'age');
console.log(ageType); // [Function: Number] ‚úÖ
```

### 2. `design:paramtypes` - Tipos de Par√°metros

```typescript
class UserService {
  createUser(name: string, age: number): boolean {
    return true;
  }
}

// TypeScript autom√°ticamente guarda tipos de par√°metros:
const paramTypes = Reflect.getMetadata(
  'design:paramtypes',
  UserService.prototype,
  'createUser'
);
console.log(paramTypes);
// [[Function: String], [Function: Number]] ‚úÖ
```

### 3. `design:returntype` - Tipo de Retorno

```typescript
class DataService {
  async getData(): Promise<User[]> {
    return [];
  }
}

// TypeScript autom√°ticamente guarda tipo de retorno:
const returnType = Reflect.getMetadata(
  'design:returntype',
  DataService.prototype,
  'getData'
);
console.log(returnType); // [Function: Promise] ‚úÖ
```

### Caso Real: Validaci√≥n Autom√°tica

```typescript
// ¬øC√≥mo NestJS valida DTOs autom√°ticamente?

function validate(instance: any, metadata: any) {
  const keys = Object.keys(instance);
  
  for (const key of keys) {
    const type = Reflect.getMetadata('design:type', instance.constructor.prototype, key);
    const value = instance[key];
    
    if (type === String && typeof value !== 'string') {
      throw new Error(`${key} must be string`);
    }
    if (type === Number && typeof value !== 'number') {
      throw new Error(`${key} must be number`);
    }
  }
}

class CreateUserDto {
  name: string;
  age: number;
}

const dto = new CreateUserDto();
dto.name = 'John'; // ‚úÖ ok
dto.age = 'twenty'; // ‚ùå Error! Must be number

validate(dto, {});
```

---

## Decorator Factories: Decorators con Par√°metros

Un **decorator factory** es una funci√≥n que retorna un decorator (para aceptar par√°metros):

### Ejemplo: @Cache()

```typescript
// ‚ùå Decorator sin par√°metros (no reutilizable)
function SimpleCache(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  // TTL hardcoded - no flexible
}

// ‚úÖ Decorator factory con par√°metros
function Cache(ttl: number) {
  // Factory retorna el decorator real
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    const cache = new Map<string, { value: any; expiry: number }>();
    
    descriptor.value = async function (...args: any[]) {
      const key = JSON.stringify(args);
      const cached = cache.get(key);
      
      if (cached && cached.expiry > Date.now()) {
        console.log('üíæ Cache hit');
        return cached.value;
      }
      
      const result = await originalMethod.apply(this, args);
      cache.set(key, { value: result, expiry: Date.now() + ttl });
      return result;
    };
    
    return descriptor;
  };
}

class DataService {
  @Cache(60000) // 60 segundos TTL
  async getData(id: string): Promise<any> {
    return fetch(`/api/data/${id}`);
  }
  
  @Cache(300000) // 5 minutos TTL - diferente per m√©todo
  async getHeavyData(): Promise<any> {
    return fetch(`/api/heavy`);
  }
}
```

### Ejemplo: @Validate()

```typescript
function Validate(schema: { [key: string]: (value: any) => boolean }) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function (...args: any[]) {
      // Validar cada par√°metro seg√∫n schema
      Object.entries(schema).forEach(([paramName, validator], index) => {
        if (!validator(args[index])) {
          throw new Error(`‚ùå Validation failed for parameter "${paramName}"`);
        }
      });
      
      return originalMethod.apply(this, args);
    };
    
    return descriptor;
  };
}

class Calculator {
  @Validate({
    dividend: (v) => typeof v === 'number' && v > 0,
    divisor: (v) => typeof v === 'number' && v > 0,
  })
  divide(dividend: number, divisor: number): number {
    return dividend / divisor;
  }
}

const calc = new Calculator();
calc.divide(10, 2); // ‚úÖ ok = 5
calc.divide(-10, 2); // ‚ùå Error! Validation failed
calc.divide(10, 0); // ‚ùå Error! Validation failed
```

---

## Composici√≥n: M√∫ltiples Decorators

### Orden de Ejecuci√≥n: De Abajo Hacia Arriba

```typescript
function First() {
  console.log('üîµ First factory');
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log('üîµ First decorator');
  };
}

function Second() {
  console.log('üü° Second factory');
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log('üü° Second decorator');
  };
}

class Example {
  @First()
  @Second()
  method() {}
}

// Output:
// üîµ First factory   ‚Üê Primero: las factories se definen de arriba a abajo
// üü° Second factory
// üü° Second decorator  ‚Üê Luego: los decorators se ejecutan de abajo a arriba
// üîµ First decorator
```

### Caso Real: NestJS Con M√∫ltiples Decorators

```typescript
@Controller('/admin')
@UseGuards(AuthGuard)
class AdminController {
  @Get('/users')
  @Roles('admin', 'superadmin')
  @Cache(300)
  @Log()
  async getUsers(): Promise<User[]> {
    // Order de ejecuci√≥n:
    // 1. @Log() - wrapper m√°s externo (logging)
    // 2. @Cache(300) - cachea resultado
    // 3. @Roles - chequea permisos
    // 4. @UseGuards(AuthGuard) - autentica al usuario
    // 5. getUsers() - m√©todo original
  }
}

// El request entra as√≠:
// request ‚Üí AuthGuard ‚Üí Roles ‚Üí @Cache ‚Üí @Log ‚Üí getUsers()
// response ‚Üê (devuelve logged + cached result)
```

---

## Casos Reales: Decorators en NestJS

### Caso 1: ORM Entity Mapping

```typescript
function Entity(tableName: string) {
  return function <T extends { new (...args: any[]): {} }>(constructor: T) {
    Reflect.defineMetadata('entity:tableName', tableName, constructor);
    return class extends constructor {
      static tableName = tableName;
    };
  };
}

function Column(options?: { name?: string; type?: string }) {
  return function (target: any, propertyKey: string) {
    const columns = Reflect.getMetadata('entity:columns', target) || {};
    columns[propertyKey] = { name: options?.name || propertyKey, type: options?.type };
    Reflect.defineMetadata('entity:columns', columns, target);
  };
}

// Uso: Autom√°ticamente mapea tipos TypeScript a SQL
@Entity('users')
class User {
  @Column({ type: 'uuid' })
  id: string;
  
  @Column({ type: 'varchar(255)' })
  name: string;
  
  @Column({ type: 'timestamp' })
  createdAt: Date;
}

// Un ORM puede leer metadata y generar SQL autom√°ticamente
```

### Caso 2: Route Handlers Type-Safe

```typescript
function Get(path: string) {
  return function (target: any, methodName: string, descriptor: PropertyDescriptor) {
    Reflect.defineMetadata('route:method', 'GET', target, methodName);
    Reflect.defineMetadata('route:path', path, target, methodName);
    return descriptor;
  };
}

function Post(path: string) {
  return function (target: any, methodName: string, descriptor: PropertyDescriptor) {
    Reflect.defineMetadata('route:method', 'POST', target, methodName);
    Reflect.defineMetadata('route:path', path, target, methodName);
    return descriptor;
  };
}

@Controller('/products')
class ProductController {
  @Get('/')
  async listProducts() { }
  
  @Get('/:id')
  async getProduct(@Param('id') id: string) { }
  
  @Post('/')
  async createProduct(@Body() createProductDto: CreateProductDto) { }
}

// NestJS lee metadata y autom√°ticamente registra rutas HTTP
```

### Caso 3: Event Bus Type-Safe

```typescript
function EventHandler(eventType: string) {
  return function (target: any, methodName: string, descriptor: PropertyDescriptor) {
    Reflect.defineMetadata('event:type', eventType, target, methodName);
    return descriptor;
  };
}

class UserEvents {
  @EventHandler('user.created')
  onUserCreated(event: UserCreatedEvent) {
    // Autom√°ticamente subscribe a 'user.created'
  }
  
  @EventHandler('user.updated')
  onUserUpdated(event: UserUpdatedEvent) {
    // Autom√°ticamente subscribe a 'user.updated'
  }
}

// El event bus lee metadata y registra handlers autom√°ticamente
```

---

## Resumen: Lo Que Aprendiste

- ‚úÖ **Concepto:** Decorators = funciones que modifican c√≥digo sin cambiar su l√≥gica
- ‚úÖ **Class Decorators:** Marcar y registrar clases (e.g., `@Injectable()`)
- ‚úÖ **Method Decorators:** Envolver m√©todos para logging, caching, retry, timeout
- ‚úÖ **Property Decorators:** Guardar metadata sobre propiedades (tipos, validaciones)
- ‚úÖ **Parameter Decorators:** Marcar de d√≥nde vienen los datos (`@Body()`, `@Param()`)
- ‚úÖ **Reflect-Metadata:** API para guardar/recuperar informaci√≥n en runtime
- ‚úÖ **Design Types:** TypeScript auto-guarda `design:type`, `design:paramtypes`, `design:returntype`
- ‚úÖ **Factories:** Decorators con par√°metros que retornan el decorator real
- ‚úÖ **Composici√≥n:** M√∫ltiples decorators se ejecutan de abajo a arriba
- ‚úÖ **NestJS:** Base de inyecci√≥n de dependencias, routing, validaci√≥n

**Lo importante:** Decorators = **automatizaci√≥n de configuraci√≥n**. Sin ellos, NestJS ser√≠a mucho m√°s verboso. Son la magia que hace posible que escribas menos c√≥digo pero hagas m√°s.

---

## üìã Checklist: ¬øEntendiste Decorators?

- ‚úÖ Decorators son funciones que reciben informaci√≥n sobre lo que decoran
- ‚úÖ Sintaxis: `@DecoratorName` sobre clase, m√©todo, propiedad o par√°metro
- ‚úÖ Class decorators: `(target: Function) => void`
- ‚úÖ Method decorators: `(target, propertyKey, descriptor) => PropertyDescriptor`
- ‚úÖ Property decorators: `(target, propertyKey) => void`
- ‚úÖ Parameter decorators: `(target, propertyKey, paramIndex) => void`
- ‚úÖ Reflect-Metadata: `defineMetadata()` y `getMetadata()` para guardar info
- ‚úÖ Design types: TypeScript guarda tipos autom√°ticamente (si habilit√°s `emitDecoratorMetadata`)
- ‚úÖ Factories: Decorators que aceptan par√°metros
- ‚úÖ Orden: Factories se definen top-to-bottom, decorators se ejecutan bottom-to-top
- ‚úÖ Casos reales: `@Injectable()`, `@Controller()`, `@Get()`, `@Body()`, `@Param()` de NestJS

**üéØ Pr√≥ximo paso:** [7. Type Guards: Narrowing de Tipos en Condicionales](./7.Type-Guards[TypeScript].md)

**üéØ Recuerda:** Decorators son herramientas de meta-programaci√≥n. Te permiten escribir c√≥digo que modifica c√≥digo. En NestJS, son fundamentales para la inyecci√≥n de dependencias y el routing autom√°tico.