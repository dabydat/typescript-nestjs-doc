# üè∑Ô∏è Branded Types: Tipos Nominales y Value Objects

## Introducci√≥n: El Problema

Imagina que tienes dos tipos que "lucen" iguales pero sem√°nticamente son muy diferentes:

```typescript
// ‚ùå Problema: Ambos son `string`, pero no deber√≠an ser intercambiables
type UserId = string;
type Email = string;

function sendEmailToUser(userId: UserId, email: Email) {
  // ¬øQu√© pasa si los paso al rev√©s por error?
  console.log(`Sending to ${userId} at ${email}`);
}

const user: UserId = 'user-123';
const mail: Email = 'juan@example.com';

sendEmailToUser(mail, user); // ‚ùå TypeScript permite esto - ¬°es un BUG!
```

Un **branded type** (tambi√©n llamado **nominal type** o **opaque type**) es una forma de crear tipos que se ven iguales pero TypeScript los trata como diferentes:

```typescript
// ‚úÖ Soluci√≥n: Crear marcas invisibles
type UserId = string & { readonly __brand: 'UserId' };
type Email = string & { readonly __brand: 'Email' };

function sendEmailToUser(userId: UserId, email: Email) {
  console.log(`Sending to ${userId} at ${email}`);
}

const user = 'user-123' as UserId; // ‚Üê Marca como UserId
const mail = 'juan@example.com' as Email; // ‚Üê Marca como Email

sendEmailToUser(mail, user); // ‚ùå Error: Type '"juan@example.com"' is not assignable to type 'UserId'
```

**Eso es un branded type:** una forma de crear tipos nominales en TypeScript que previenen errores al confundir valores que son strings pero significan cosas diferentes.

---

## üìã √çndice - S√∫per Simple

1. [Concepto Base: La Marca Invisible](#base)
2. [Branded Helpers: Funciones de Conversi√≥n](#helpers)
3. [Runtime Validation: Marcas Seguras](#validation)
4. [Value Objects: Objetos Inmutables con Identidad](#value-objects)
5. [Branded Unions: Tipos Discriminados + Branded](#branded-unions)
6. [Casos Reales: Domain-Driven Design](#ddd)
7. [Patrones NestJS: DTOs + Branded](#nestjs)
8. [Ventajas y Desventajas](#tradeoffs)

---

## Concepto Base: La Marca Invisible {#base}

Un branded type combina un tipo base con una propiedad "invisible" que solo existe en el sistema de tipos:

### Ejemplo 1: Monedas Diferentes

```typescript
// ‚úÖ Crear marcas para diferentes monedas
type USD = number & { readonly __brand: 'USD' };
type EUR = number & { readonly __brand: 'EUR' };

// ‚úÖ Helper para crear valores marcados
function createUSD(amount: number): USD {
  return amount as USD;
}

function createEUR(amount: number): EUR {
  return amount as EUR;
}

function totalInUSD(usd: USD, eur: EUR): USD {
  // ‚ùå Error: Cannot assign EUR to USD
  // return (usd + eur) as USD;
  
  // ‚úÖ Conversi√≥n expl√≠cita
  const exchangeRate = 1.08;
  return (usd + eur * exchangeRate) as USD;
}

// Uso:
const wallet1: USD = createUSD(100);
const wallet2: EUR = createEUR(50);

totalInUSD(wallet1, wallet2); // ‚úÖ Expl√≠cito
totalInUSD(wallet2, wallet1); // ‚ùå Error: Argument of type 'EUR' is not assignable to parameter of type 'USD'
```

### Ejemplo 2: Tipos de ID

```typescript
// ‚ùå Todos son strings - f√°cil confundirse
type UserId = string;
type ProductId = string;
type OrderId = string;

// ‚úÖ Con branded types - cada uno es √∫nico
type UserId = string & { readonly __brand: 'UserId' };
type ProductId = string & { readonly __brand: 'ProductId' };
type OrderId = string & { readonly __brand: 'OrderId' };

// Helpers para crear IDs
const createUserId = (id: string): UserId => id as UserId;
const createProductId = (id: string): ProductId => id as ProductId;
const createOrderId = (id: string): OrderId => id as OrderId;

// Funci√≥n que necesita IDs espec√≠ficos
function createOrder(userId: UserId, productId: ProductId): OrderId {
  const orderId = `order-${Date.now()}`;
  console.log(`Order created for user ${userId} with product ${productId}`);
  return createOrderId(orderId);
}

// Uso:
const user: UserId = createUserId('user-123');
const product: ProductId = createProductId('prod-456');

createOrder(user, product); // ‚úÖ OK
createOrder(product, user); // ‚ùå Error: Type 'ProductId' is not assignable to type 'UserId'
```

---

## Branded Helpers: Funciones de Conversi√≥n {#helpers}

Para crear branded types de forma c√≥moda, necesitas helpers que hagan la conversi√≥n:

### Pattern 1: Constructor Simple

```typescript
type Email = string & { readonly __brand: 'Email' };

// Helper simple
function createEmail(email: string): Email {
  return email as Email;
}

// Uso:
const myEmail = createEmail('juan@example.com');
console.log(myEmail); // "juan@example.com" (en runtime es string normal)
```

### Pattern 2: Constructor con Validaci√≥n

```typescript
type Email = string & { readonly __brand: 'Email' };

// Helper con validaci√≥n
function createEmail(email: string): Email | null {
  if (!email.includes('@')) {
    return null;
  }
  return email as Email;
}

// Uso:
const validEmail = createEmail('juan@example.com'); // Email | null
const invalidEmail = createEmail('juan'); // Email | null

if (validEmail) {
  console.log(`‚úÖ Email v√°lido: ${validEmail}`);
}
```

### Pattern 3: Constructor que Explota

```typescript
type Email = string & { readonly __brand: 'Email' };

// Helper que explota si es inv√°lido
function createEmailOrThrow(email: string): Email {
  if (!email.includes('@')) {
    throw new Error(`Invalid email: ${email}`);
  }
  return email as Email;
}

// Uso:
try {
  const myEmail = createEmailOrThrow('juan@example.com');
  console.log(`‚úÖ Email v√°lido: ${myEmail}`);
} catch (error) {
  console.error(error.message);
}
```

### Pattern 4: Constructor que Asegura

```typescript
type Email = string & { readonly __brand: 'Email' };

// Helper con type predicate
function isEmail(value: string): value is Email {
  return value.includes('@');
}

function createEmail(email: string): Email {
  if (!isEmail(email)) {
    throw new Error(`Invalid email: ${email}`);
  }
  return email;
}

// Ahora en otros lados puedo usar el type guard:
const email: string = 'juan@example.com';

if (isEmail(email)) {
  // Aqu√≠ email es Email
  console.log(`‚úÖ ${email}`);
}
```

---

## Runtime Validation: Marcas Seguras {#validation}

Los branded types son **solo de compilaci√≥n**. Para seguridad real, necesitas validaci√≥n en runtime:

### Ejemplo: Crear IDs Seguros

```typescript
type UserId = string & { readonly __brand: 'UserId' };

// ‚úÖ Validaci√≥n + conversion
function createUserId(value: unknown): UserId {
  // Validar que sea string
  if (typeof value !== 'string') {
    throw new Error(`UserId must be string, got ${typeof value}`);
  }

  // Validar que no est√© vac√≠o
  if (value.length === 0) {
    throw new Error('UserId cannot be empty');
  }

  // Validar formato (ejemplo: debe empezar con "user-")
  if (!value.startsWith('user-')) {
    throw new Error(`UserId must start with "user-", got "${value}"`);
  }

  return value as UserId;
}

// Uso:
try {
  const userId = createUserId('user-123');
  console.log(`‚úÖ Valid UserId: ${userId}`);
} catch (error) {
  console.error(`‚ùå ${error.message}`);
}

// Intentos inv√°lidos:
createUserId(123); // ‚ùå Error: UserId must be string
createUserId(''); // ‚ùå Error: UserId cannot be empty
createUserId('admin-123'); // ‚ùå Error: UserId must start with "user-"
```

### Ejemplo: Validar Enums

```typescript
type Role = 'admin' | 'user' | 'guest';
type ValidatedRole = Role & { readonly __brand: 'ValidatedRole' };

function createValidatedRole(value: unknown): ValidatedRole {
  const validRoles: Role[] = ['admin', 'user', 'guest'];

  if (!validRoles.includes(value as Role)) {
    throw new Error(
      `Invalid role: "${value}". Must be one of: ${validRoles.join(', ')}`
    );
  }

  return value as ValidatedRole;
}

// Uso:
try {
  const role = createValidatedRole('admin');
  console.log(`‚úÖ Role: ${role}`);
} catch (error) {
  console.error(error.message);
}
```

---

## Value Objects: Objetos Inmutables con Identidad {#value-objects}

Un **Value Object** es un objeto que se identifica por sus valores, no por una ID. Los branded types combinan bien con ellos:

### Ejemplo 1: Money (Dinero)

```typescript
// Tipo branded para cantidad
type MoneyAmount = number & { readonly __brand: 'MoneyAmount' };

// Value Object: Money
class Money {
  readonly amount: MoneyAmount;
  readonly currency: 'USD' | 'EUR' | 'ARS';

  constructor(amount: number, currency: 'USD' | 'EUR' | 'ARS') {
    if (amount < 0) {
      throw new Error('Amount cannot be negative');
    }
    this.amount = amount as MoneyAmount;
    this.currency = currency;
  }

  // Suma otro dinero
  add(other: Money): Money {
    if (this.currency !== other.currency) {
      throw new Error('Cannot add different currencies');
    }
    return new Money(this.amount + other.amount, this.currency);
  }

  // Multiplica
  multiply(factor: number): Money {
    if (factor < 0) {
      throw new Error('Factor cannot be negative');
    }
    return new Money(this.amount * factor, this.currency);
  }

  // Igualdad (Value Objects se comparan por valor, no por identidad)
  equals(other: Money): boolean {
    return this.amount === other.amount && this.currency === other.currency;
  }

  // String representation
  toString(): string {
    return `${this.currency} ${this.amount}`;
  }
}

// Uso:
const price = new Money(100, 'USD');
const tax = new Money(10, 'USD');
const total = price.add(tax); // Money { amount: 110, currency: 'USD' }

console.log(`Total: ${total}`); // Total: USD 110
console.log(total.equals(new Money(110, 'USD'))); // true (Value Object)
```

### Ejemplo 2: Email (Address)

```typescript
type EmailString = string & { readonly __brand: 'EmailString' };

class Email {
  readonly value: EmailString;

  constructor(email: string) {
    // Validar formato
    if (!this.isValidEmail(email)) {
      throw new Error(`Invalid email: ${email}`);
    }
    this.value = email as EmailString;
  }

  private isValidEmail(email: string): boolean {
    // Regex simple (en producci√≥n usar algo m√°s robusto)
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }

  // Obtener dominio
  getDomain(): string {
    return this.value.split('@')[1];
  }

  // Igualdad
  equals(other: Email): boolean {
    return this.value.toLowerCase() === other.value.toLowerCase();
  }

  // String representation
  toString(): string {
    return this.value;
  }
}

// Uso:
const email1 = new Email('juan@example.com');
const email2 = new Email('JUAN@EXAMPLE.COM');

console.log(email1.getDomain()); // "example.com"
console.log(email1.equals(email2)); // true (case-insensitive)

try {
  new Email('invalid-email'); // ‚ùå Error: Invalid email
} catch (error) {
  console.error(error.message);
}
```

### Ejemplo 3: UserId (Aggregate Root Identifier)

```typescript
type UserIdValue = string & { readonly __brand: 'UserIdValue' };

class UserId {
  readonly value: UserIdValue;

  constructor(value: string) {
    if (!value.startsWith('user-')) {
      throw new Error(`UserId must start with "user-"`);
    }
    this.value = value as UserIdValue;
  }

  // Factory: generar nuevo ID
  static generate(): UserId {
    return new UserId(`user-${Date.now()}-${Math.random()}`);
  }

  // Igualdad
  equals(other: UserId): boolean {
    return this.value === other.value;
  }

  // String representation
  toString(): string {
    return this.value;
  }
}

// Uso:
const id1 = UserId.generate();
const id2 = UserId.generate();

console.log(id1.toString()); // "user-1730981234567-0.123456"
console.log(id1.equals(id2)); // false (diferentes IDs)
```

---

## Branded Unions: Tipos Discriminados + Branded {#branded-unions}

Combin√° branded types con discriminated unions para m√°xima seguridad:

```typescript
// Branded types
type AdminRole = string & { readonly __brand: 'AdminRole' };
type UserRole = string & { readonly __brand: 'UserRole' };

// Discriminated union de roles
type Role = 
  | { type: 'admin'; permissions: string[]; role: AdminRole }
  | { type: 'user'; userId: string; role: UserRole };

// Funciones de creaci√≥n segura
function createAdminRole(permissionList: string[]): Role {
  return {
    type: 'admin',
    permissions: permissionList,
    role: 'admin-role' as AdminRole
  };
}

function createUserRole(userId: string): Role {
  return {
    type: 'user',
    userId,
    role: 'user-role' as UserRole
  };
}

// Handler type-safe
function handleRole(role: Role) {
  switch (role.type) {
    case 'admin':
      // role.role es AdminRole
      // role.permissions existe
      console.log(`Admin with permissions: ${role.permissions.join(', ')}`);
      break;

    case 'user':
      // role.role es UserRole
      // role.userId existe
      console.log(`User ${role.userId}`);
      break;
  }
}

// Uso:
const adminRole = createAdminRole(['read', 'write', 'delete']);
const userRole = createUserRole('user-123');

handleRole(adminRole);
handleRole(userRole);
```

---

## Casos Reales: Domain-Driven Design {#ddd}

Branded types + Value Objects son fundamentales en **DDD** (Domain-Driven Design):

### Ejemplo: E-commerce Order

```typescript
// Branded IDs
type OrderId = string & { readonly __brand: 'OrderId' };
type CustomerId = string & { readonly __brand: 'CustomerId' };
type ProductId = string & { readonly __brand: 'ProductId' };

// Value Objects
class Money {
  constructor(readonly amount: number, readonly currency: string) {
    if (amount < 0) throw new Error('Negative amount');
  }

  add(other: Money): Money {
    if (this.currency !== other.currency) throw new Error('Different currencies');
    return new Money(this.amount + other.amount, this.currency);
  }

  equals(other: Money): boolean {
    return this.amount === other.amount && this.currency === other.currency;
  }
}

class OrderLineItem {
  constructor(
    readonly productId: ProductId,
    readonly quantity: number,
    readonly unitPrice: Money
  ) {}

  getTotal(): Money {
    return new Money(this.unitPrice.amount * this.quantity, this.unitPrice.currency);
  }
}

// Aggregate: Order
class Order {
  readonly id: OrderId;
  readonly customerId: CustomerId;
  readonly lineItems: OrderLineItem[];
  readonly status: 'pending' | 'shipped' | 'delivered';
  readonly createdAt: Date;

  constructor(
    id: OrderId,
    customerId: CustomerId,
    lineItems: OrderLineItem[]
  ) {
    if (lineItems.length === 0) throw new Error('Order must have items');

    this.id = id;
    this.customerId = customerId;
    this.lineItems = lineItems;
    this.status = 'pending';
    this.createdAt = new Date();
  }

  // Calculate total
  getTotal(): Money {
    return this.lineItems.reduce(
      (acc, item) => acc.add(item.getTotal()),
      new Money(0, 'USD')
    );
  }

  // Transitions (invariants check)
  ship(): void {
    if (this.status !== 'pending') {
      throw new Error(`Cannot ship order with status ${this.status}`);
    }
    // (this.status) = 'shipped'; ‚Üê Can't mutate directly
    // Use event sourcing or state machine pattern
  }
}

// Factory
function createOrder(
  customerId: string,
  items: Array<{ productId: string; quantity: number; unitPrice: number }>
): Order {
  const orderId = `order-${Date.now()}` as OrderId;
  const cId = customerId as CustomerId;
  const lineItems = items.map(
    item =>
      new OrderLineItem(
        item.productId as ProductId,
        item.quantity,
        new Money(item.unitPrice, 'USD')
      )
  );

  return new Order(orderId, cId, lineItems);
}

// Uso:
const order = createOrder('customer-123', [
  { productId: 'prod-1', quantity: 2, unitPrice: 100 },
  { productId: 'prod-2', quantity: 1, unitPrice: 50 }
]);

console.log(`Order total: ${order.getTotal()}`); // Order total: Money { amount: 250, currency: 'USD' }
```

---

## Patrones NestJS: DTOs + Branded {#nestjs}

### Patr√≥n: Validar DTOs en Controllers

```typescript
// Archivo: shared/types/branded.ts
export type UserId = string & { readonly __brand: 'UserId' };
export type Email = string & { readonly __brand: 'Email' };

// Archivo: shared/validators/user-id.validator.ts
import { UserId } from '../types/branded';

export function createUserId(value: string): UserId {
  if (!value.startsWith('user-')) {
    throw new Error(`Invalid UserId: ${value}`);
  }
  return value as UserId;
}

// Archivo: users/dtos/create-user.dto.ts
import { IsString, IsEmail as IsEmailDecorator } from 'class-validator';

export class CreateUserDto {
  @IsString()
  name: string;

  @IsEmailDecorator()
  email: string;
}

// Archivo: users/users.controller.ts
import { Controller, Post, Body } from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto } from './dtos/create-user.dto';
import { createUserId } from '../shared/validators/user-id.validator';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  async createUser(@Body() createUserDto: CreateUserDto) {
    // En este punto, DTO est√° validado por class-validator
    const userId = createUserId(`user-${Date.now()}`);
    
    return this.usersService.create(userId, createUserDto.email);
  }
}

// Archivo: users/users.service.ts
import { Injectable } from '@nestjs/common';
import { UserId, Email } from '../shared/types/branded';

@Injectable()
export class UsersService {
  async create(userId: UserId, email: string): Promise<{ id: UserId; email: string }> {
    // userId es garantizado ser v√°lido (branded type)
    // email es garantizado ser string (validado por DTO)
    
    console.log(`Creating user ${userId} with email ${email}`);
    
    return {
      id: userId,
      email
    };
  }
}
```

---

## Ventajas y Desventajas {#tradeoffs}

### ‚úÖ Ventajas de Branded Types

- **Type Safety:** Previenen confundir valores que lucen iguales pero son sem√°nticamente diferentes
- **Self-Documenting:** El c√≥digo es m√°s claro sobre qu√© tipo se espera
- **No Runtime Cost:** Las marcas existen solo en compilaci√≥n, sin overhead
- **Works Well with DDD:** Perfecto para Value Objects y Aggregates
- **Exhaustiveness Checking:** Combinado con discriminated unions, TypeScript te ayuda a no olvidar casos

### ‚ùå Desventajas de Branded Types

- **Type Assertion Magic:** Necesitas `as` para crear valores brandedos, lo que puede ser peligroso
- **No Runtime Validation:** La marca desaparece en runtime, solo existe en compilaci√≥n
- **Verbose:** Necesitas escribir constructores y helpers para cada branded type
- **Learning Curve:** Es un concepto avanzado de TypeScript
- **Interoperabilidad:** Dif√≠cil compartir branded types con c√≥digo JavaScript o librer√≠as sin tipos

### üí° Cu√°ndo Usarlos

**Usa Branded Types cuando:**
- Tienes m√∫ltiples tipos que lucen iguales (strings, numbers) pero son conceptualmente diferentes
- Trabajas con Domain-Driven Design
- Necesitas m√°xima type safety en tu aplicaci√≥n
- Quer√©s evitar bugs sutiles por confundir tipos

**NO los uses cuando:**
- Solo necesitas simples type aliases
- El overhead de validaci√≥n no vale la pena
- Trabajas en c√≥digo que necesita interoperar con JavaScript puro

---

## Resumen: Lo Que Aprendiste {#resumen}

- ‚úÖ **Branded Types:** Crear marcas invisibles para tipos que lucen iguales pero son diferentes
- ‚úÖ **Nominal Typing:** TypeScript normalmente es estructural, branded types hacen que sea nominal
- ‚úÖ **Helpers y Constructores:** Funciones para crear branded types de forma segura
- ‚úÖ **Value Objects:** Objetos inmutables que se comparan por valor, no por identidad
- ‚úÖ **Domain-Driven Design:** Branded types + Value Objects son la base de DDD
- ‚úÖ **Runtime Validation:** Validar en runtime para seguridad real, no solo en tipos
- ‚úÖ **Branded Unions:** Combinar branded types con discriminated unions
- ‚úÖ **NestJS Integration:** Usar en DTOs y services para m√°xima type safety
- ‚úÖ **Tradeoffs:** Entender cu√°ndo usarlos y cu√°ndo no vale la pena

**Lo importante:** Branded Types = **m√°xima claridad + m√°xima seguridad**. Transforman la sem√°ntica en el sistema de tipos, previniendo bugs que TypeScript estructural no puede detectar.

---

## üìã Checklist: ¬øEntendiste Branded Types?

- ‚úÖ Entiendo la diferencia entre tipado estructural y nominal
- ‚úÖ Puedo crear un branded type: `type MyType = string & { readonly __brand: 'MyType' }`
- ‚úÖ S√© c√≥mo crear valores branded usando `as` para conversi√≥n
- ‚úÖ Entiendo por qu√© branded types no tienen costo en runtime
- ‚úÖ Puedo crear helpers/constructores para branded types
- ‚úÖ Entiendo Value Objects y c√≥mo se comparan por valor
- ‚úÖ Puedo validar en runtime antes de crear branded types
- ‚úÖ Entiendo c√≥mo combinar branded types con discriminated unions
- ‚úÖ Puedo implementar Domain-Driven Design con branded types
- ‚úÖ S√© cu√°ndo usar branded types y cu√°ndo no es necesario
- ‚úÖ Entiendo el tradeoff entre seguridad y complejidad

**üéØ Record√°:** Branded Types son el nivel AVANZADO de TypeScript. Una vez que los dominas, Tu c√≥digo se vuelve incre√≠blemente seguro y autodocumentado.

**üéØ √âxito:** ¬°Completaste los 9 cap√≠tulos avanzados de TypeScript! Ahora tienes herramientas de nivel profesional para escribir c√≥digo ultra type-safe üöÄ
