# üéØ Discriminated Unions: Pattern Matching Avanzado

## Introducci√≥n: El Problema

Imagina que tu aplicaci√≥n maneja diferentes "estados" o "respuestas", y necesitas trabajar de forma segura con cada uno:

```typescript
// ‚ùå Problema: No sabemos qu√© tipo es
type ApiResponse = SuccessResponse | ErrorResponse | LoadingResponse;

function handleResponse(response: ApiResponse) {
  // ¬øtengo response.data o response.error?
  // ¬øtengo response.status?
  // No s√© cu√°l de los tres es...
}
```

Un **discriminated union** (tambi√©n llamado **tagged union** o **sum type**) es simplemente agregar una **propiedad marcadora** a cada tipo:

```typescript
// ‚úÖ Soluci√≥n: Agregar un 'type' o 'status' que lo identifique
type SuccessResponse = { type: 'success'; data: User };
type ErrorResponse = { type: 'error'; error: string };
type LoadingResponse = { type: 'loading' };

type ApiResponse = SuccessResponse | ErrorResponse | LoadingResponse;

function handleResponse(response: ApiResponse) {
  switch (response.type) {
    case 'success':
      // Aqu√≠ SOLO tienes response.data
      return `üë§ ${response.data.name}`;
    
    case 'error':
      // Aqu√≠ SOLO tienes response.error
      return `‚ö†Ô∏è ${response.error}`;
    
    case 'loading':
      // Aqu√≠ no tienes ni data ni error
      return '‚è≥ Loading...';
  }
}
```

**Eso es un discriminated union:** un tipo que usa una propiedad marcadora para que TypeScript sepa exactamente cu√°l de los posibles tipos tienes en cada rama.

---

## üìã √çndice - S√∫per Simple

1. [Concepto Base: La Propiedad Discriminadora](#base)
2. [Narrowing Autom√°tico: El Type Guard Impl√≠cito](#narrowing)
3. [Switch vs If: D√≥nde Usar Cada Uno](#switch-vs-if)
4. [Exhaustiveness Checking: ¬øCubriste Todos los Casos?](#exhaustiveness)
5. [Patrones Reales: State Management](#state-management)
6. [Patrones Reales: Result Types](#result-types)
7. [Patrones Reales: API Responses](#api-responses)
8. [M√∫ltiples Discriminadores](#multiple-discriminators)
9. [Discriminated Unions en NestJS](#nestjs)

---

## Concepto Base: La Propiedad Discriminadora {#base}

La idea es simple: **una propiedad que identifica qu√© tipo realmente eres**.

### Ejemplo 1: Estados de Carrito

```typescript
// Sin discriminador: confuso
type CartState = 
  | { items: Product[] }           // ¬øqu√© significa?
  | { error: string; retry: boolean } // ¬øcu√°ndo est√° vac√≠o?
  | { isLoading: true };           // ¬øes v√°lido tener items y loading juntos?

// ‚ùå Problema: No sabes qu√© tipo es

// Con discriminador: claro
type CartEmpty = { type: 'empty' };
type CartLoading = { type: 'loading' };
type CartLoaded = { type: 'loaded'; items: Product[] };
type CartError = { type: 'error'; error: string };

type CartState = CartEmpty | CartLoading | CartLoaded | CartError;

// ‚úÖ Soluci√≥n: Siempre sabes qu√© tipo es por `type`
```

### Ejemplo 2: Acciones Redux

```typescript
// ‚ùå Sin discriminador: ambiguo
type Action = {
  type?: string;
  payload?: any;
  error?: string;
};

// ‚úÖ Con discriminador: preciso
type IncrementAction = { type: 'INCREMENT'; payload: number };
type DecrementAction = { type: 'DECREMENT'; payload: number };
type ResetAction = { type: 'RESET' };

type Action = IncrementAction | DecrementAction | ResetAction;

function reducer(state: number, action: Action) {
  switch (action.type) {
    case 'INCREMENT':
      return state + action.payload; // ‚úÖ payload existe
    
    case 'DECREMENT':
      return state - action.payload; // ‚úÖ payload existe
    
    case 'RESET':
      return 0; // ‚úÖ no necesit√°s payload
  }
}
```

---

## Narrowing Autom√°tico: El Type Guard Impl√≠cito {#narrowing}

Cuando usas un discriminated union, TypeScript **autom√°ticamente** entiende qu√© propiedades existen:

```typescript
type Circle = { type: 'circle'; radius: number };
type Rectangle = { type: 'rectangle'; width: number; height: number };
type Shape = Circle | Rectangle;

function calculateArea(shape: Shape) {
  // ‚ùå Error sin narrowing:
  // return shape.radius; // Property 'radius' does not exist on type 'Rectangle'
  // return shape.width;  // Property 'width' does not exist on type 'Circle'

  // ‚úÖ Con narrowing - TypeScript te sigue autom√°ticamente:
  if (shape.type === 'circle') {
    // Aqu√≠ shape es Circle
    return Math.PI * shape.radius ** 2;
  }
  
  if (shape.type === 'rectangle') {
    // Aqu√≠ shape es Rectangle
    return shape.width * shape.height;
  }
}

// ‚úÖ Tambi√©n funciona con switch (m√°s claro):
function calculateArea2(shape: Shape) {
  switch (shape.type) {
    case 'circle':
      return Math.PI * shape.radius ** 2;
    
    case 'rectangle':
      return shape.width * shape.height;
  }
}
```

**Lo importante:** No necesit√°s escribir `shape.type === 'circle' ? ...` dos veces. TypeScript **entiende** que si `type === 'circle'`, entonces debe ser `Circle`.

---

## Switch vs If: D√≥nde Usar Cada Uno {#switch-vs-if}

### Switch: El Est√°ndar para Discriminated Unions

```typescript
type UserAction = 
  | { type: 'LOGIN'; email: string; password: string }
  | { type: 'LOGOUT' }
  | { type: 'UPDATE_PROFILE'; name: string; avatar: string }
  | { type: 'DELETE_ACCOUNT' };

function handleUserAction(action: UserAction) {
  // ‚úÖ Switch: limpio, visual, f√°cil de extender
  switch (action.type) {
    case 'LOGIN':
      console.log(`Logging in with ${action.email}`);
      break;
    
    case 'LOGOUT':
      console.log('Logging out');
      break;
    
    case 'UPDATE_PROFILE':
      console.log(`Updating profile to ${action.name}`);
      break;
    
    case 'DELETE_ACCOUNT':
      console.log('Account deleted');
      break;
  }
}
```

### If: Para Casos Raros

```typescript
type Response = 
  | { type: 'success'; data: any }
  | { type: 'error'; code: number };

function handleResponse(response: Response) {
  // ‚úÖ If: √∫til si necesit√°s hacer algo antes de ramificar
  const timestamp = new Date();
  
  if (response.type === 'success') {
    console.log(`Success at ${timestamp}: ${response.data}`);
  } else {
    console.log(`Error at ${timestamp}: code ${response.code}`);
  }
}
```

**Regla:** Usa **switch** cuando tienes 3+ casos. Usa **if** cuando son solo 2 o necesit√°s hacer algo antes de ramificar.

---

## Exhaustiveness Checking: ¬øCubriste Todos los Casos? {#exhaustiveness}

Uno de los superpoderes de los discriminated unions: **TypeScript te obliga a cubrir TODOS los casos**.

### Ejemplo 1: Falta un Caso

```typescript
type Status = 'pending' | 'approved' | 'rejected';

type Request = 
  | { type: 'pending'; createdAt: Date }
  | { type: 'approved'; approvedBy: string }
  | { type: 'rejected'; reason: string };

function getStatusColor(request: Request): string {
  switch (request.type) {
    case 'pending':
      return 'yellow';
    
    case 'approved':
      return 'green';
    
    // ‚ùå Error: Missing case 'rejected'
    // TypeScript dice: Type 'Request' is not assignable to type 'never'
  }
}
```

### Soluci√≥n 1: Cubrir Todos los Casos

```typescript
function getStatusColor(request: Request): string {
  switch (request.type) {
    case 'pending':
      return 'yellow';
    
    case 'approved':
      return 'green';
    
    case 'rejected':  // ‚úÖ Agregamos el caso que faltaba
      return 'red';
  }
}
```

### Soluci√≥n 2: Usar Default + Exhaust Helper

```typescript
// Esta funci√≥n fuerza que le pases 'never'
function exhaustive(value: never): never {
  throw new Error(`Exhaustive check failed with value: ${value}`);
}

function getStatusColor(request: Request): string {
  switch (request.type) {
    case 'pending':
      return 'yellow';
    
    case 'approved':
      return 'green';
    
    case 'rejected':
      return 'red';
    
    default:
      // Si agregamos un nuevo tipo a Request pero olvidamos el caso,
      // TypeScript te avisa porque 'never' no es compatible
      return exhaustive(request.type);
  }
}
```

---

## Patrones Reales: State Management {#state-management}

### Redux-Style: Acciones Discriminadas

```typescript
type CounterState = number;

type CounterAction = 
  | { type: 'INCREMENT'; payload: number }
  | { type: 'DECREMENT'; payload: number }
  | { type: 'RESET' }
  | { type: 'SET'; payload: number };

function counterReducer(state: CounterState, action: CounterAction): CounterState {
  switch (action.type) {
    case 'INCREMENT':
      return state + action.payload;
    
    case 'DECREMENT':
      return state - action.payload;
    
    case 'RESET':
      return 0;
    
    case 'SET':
      return action.payload;
  }
}

// Uso:
let count = 0;
count = counterReducer(count, { type: 'INCREMENT', payload: 5 }); // 5
count = counterReducer(count, { type: 'DECREMENT', payload: 2 }); // 3
count = counterReducer(count, { type: 'RESET' }); // 0
```

### React-Style: Estados Complejos

```typescript
type UserData = { id: number; name: string; email: string };

type UserState = 
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: UserData }
  | { status: 'error'; error: string; retryCount: number };

function renderUserState(state: UserState): string {
  switch (state.status) {
    case 'idle':
      return '‚ùå No hay datos';
    
    case 'loading':
      return '‚è≥ Cargando...';
    
    case 'success':
      return `‚úÖ ${state.data.name} (${state.data.email})`;
    
    case 'error':
      return `‚ö†Ô∏è Error: ${state.error} (Reintentos: ${state.retryCount})`;
  }
}

// Uso:
console.log(renderUserState({ status: 'idle' }));
console.log(renderUserState({ status: 'loading' }));
console.log(renderUserState({ 
  status: 'success', 
  data: { id: 1, name: 'Juan', email: 'juan@example.com' } 
}));
console.log(renderUserState({ 
  status: 'error', 
  error: 'Network timeout', 
  retryCount: 2 
}));
```

---

## Patrones Reales: Result Types {#result-types}

Muchas librer√≠as usan discriminated unions para `Result<T, E>` sin excepciones:

```typescript
// Patr√≥n Rust-inspired: Result Type
type Success<T> = { type: 'success'; value: T };
type Failure<E> = { type: 'failure'; error: E };

type Result<T, E = string> = Success<T> | Failure<E>;

// Ejemplo: Validar email
function validateEmail(email: string): Result<string, { field: string; message: string }> {
  if (!email.includes('@')) {
    return {
      type: 'failure',
      error: { field: 'email', message: 'Email debe contener @' }
    };
  }

  return {
    type: 'success',
    value: email
  };
}

// Uso seguro sin try/catch:
const emailResult = validateEmail('juan@example.com');

switch (emailResult.type) {
  case 'success':
    console.log(`‚úÖ Email v√°lido: ${emailResult.value}`);
    break;
  
  case 'failure':
    console.log(`‚ùå ${emailResult.error.message}`);
    break;
}

// Mejor: Funci√≥n helper para encadenar
function mapResult<T, U, E>(result: Result<T, E>, fn: (value: T) => Result<U, E>): Result<U, E> {
  if (result.type === 'success') {
    return fn(result.value);
  }
  return result;
}

// Encadenar validaciones:
const email = validateEmail('juan@example.com')
  .type === 'success' 
    ? validateEmail('juan@example.com').value 
    : '';
```

---

## Patrones Reales: API Responses {#api-responses}

```typescript
type ApiResponse<T> = 
  | { status: 200; data: T }
  | { status: 201; data: T; location: string }
  | { status: 400; error: { field: string; message: string }[] }
  | { status: 401; error: 'Unauthorized' }
  | { status: 404; error: 'Not Found' }
  | { status: 500; error: 'Internal Server Error' };

type User = { id: number; name: string; email: string };

function handleUserResponse(response: ApiResponse<User>) {
  switch (response.status) {
    case 200:
      console.log(`‚úÖ Usuario: ${response.data.name}`);
      break;
    
    case 201:
      console.log(`‚úÖ Creado en: ${response.location}`);
      console.log(`üìç Usuario: ${response.data.name}`);
      break;
    
    case 400:
      console.log(`‚ùå Validaci√≥n:`);
      response.error.forEach(err => 
        console.log(`  - ${err.field}: ${err.message}`)
      );
      break;
    
    case 401:
      console.log(`üîê ${response.error}`);
      break;
    
    case 404:
      console.log(`üîç ${response.error}`);
      break;
    
    case 500:
      console.log(`üí• ${response.error}`);
      break;
  }
}

// Uso:
handleUserResponse({ status: 200, data: { id: 1, name: 'Juan', email: 'juan@example.com' } });
handleUserResponse({ status: 400, error: [{ field: 'email', message: 'Email inv√°lido' }] });
handleUserResponse({ status: 404, error: 'Not Found' });
```

---

## M√∫ltiples Discriminadores {#multiple-discriminators}

A veces necesit√°s m√°s de una propiedad para discriminar:

```typescript
// Ejemplo: Notificaciones con kind y prioridad
type Notification = 
  | { kind: 'email'; priority: 'high'; recipient: string; subject: string }
  | { kind: 'email'; priority: 'low'; recipient: string; body: string }
  | { kind: 'sms'; priority: 'high'; phone: string; message: string }
  | { kind: 'push'; priority: 'low'; deviceId: string; title: string };

function sendNotification(notif: Notification) {
  // Discriminar por 'kind'
  if (notif.kind === 'email') {
    // Aqu√≠ tienes recipient y priority
    if (notif.priority === 'high') {
      console.log(`üìß Email prioritario a ${notif.recipient}: ${notif.subject}`);
    } else {
      console.log(`üìß Email normal a ${notif.recipient}: ${notif.body}`);
    }
  }
  
  if (notif.kind === 'sms') {
    console.log(`üì± SMS a ${notif.phone}: ${notif.message}`);
  }
  
  if (notif.kind === 'push') {
    console.log(`üîî Push a ${notif.deviceId}: ${notif.title}`);
  }
}

// Uso:
sendNotification({ 
  kind: 'email', 
  priority: 'high', 
  recipient: 'boss@company.com', 
  subject: 'URGENTE' 
});
```

---

## Discriminated Unions en NestJS {#nestjs}

### Patr√≥n 1: Respuestas Uniformes

```typescript
// Archivo: shared/types/api-response.ts
export type ApiResponse<T> = 
  | { success: true; data: T }
  | { success: false; error: string; code: string };

// Archivo: shared/dtos/user.dto.ts
export interface CreateUserDto {
  name: string;
  email: string;
}

export interface UserDto {
  id: number;
  name: string;
  email: string;
}

// Archivo: users/users.controller.ts
import { Controller, Post, Body } from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto, UserDto } from '../shared/dtos/user.dto';
import { ApiResponse } from '../shared/types/api-response';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  async createUser(@Body() createUserDto: CreateUserDto): Promise<ApiResponse<UserDto>> {
    try {
      const user = await this.usersService.create(createUserDto);
      return {
        success: true,
        data: user
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        code: 'INTERNAL_ERROR'
      };
    }
  }
}
```

### Patr√≥n 2: Excepciones Personalizadas

```typescript
// Archivo: shared/exceptions/app.exception.ts
export type AppException = 
  | { type: 'VALIDATION_ERROR'; fields: { field: string; message: string }[] }
  | { type: 'NOT_FOUND'; resource: string; id: string }
  | { type: 'UNAUTHORIZED' }
  | { type: 'FORBIDDEN' }
  | { type: 'INTERNAL_ERROR'; message: string };

// Archivo: shared/filters/exception.filter.ts
import { Catch, ArgumentsHost, ExceptionFilter } from '@nestjs/common';
import { Response } from 'express';
import { AppException } from '../exceptions/app.exception';

@Catch()
export class AppExceptionFilter implements ExceptionFilter {
  catch(exception: AppException, host: ArgumentsHost) {
    const response = host.switchToHttp().getResponse<Response>();

    switch (exception.type) {
      case 'VALIDATION_ERROR':
        response.status(400).json({
          status: 400,
          message: 'Validation failed',
          errors: exception.fields
        });
        break;

      case 'NOT_FOUND':
        response.status(404).json({
          status: 404,
          message: `${exception.resource} with id ${exception.id} not found`
        });
        break;

      case 'UNAUTHORIZED':
        response.status(401).json({
          status: 401,
          message: 'Unauthorized'
        });
        break;

      case 'FORBIDDEN':
        response.status(403).json({
          status: 403,
          message: 'Forbidden'
        });
        break;

      case 'INTERNAL_ERROR':
        response.status(500).json({
          status: 500,
          message: 'Internal server error',
          details: exception.message
        });
        break;
    }
  }
}
```

### Patr√≥n 3: Validaci√≥n de DTOs

```typescript
// Archivo: users/dtos/create-user.dto.ts
import { IsString, IsEmail, MinLength, Validate } from 'class-validator';

export class CreateUserDto {
  @IsString()
  @MinLength(3)
  name: string;

  @IsEmail()
  email: string;
}

// Archivo: shared/types/validation-result.ts
export type ValidationResult<T> = 
  | { valid: true; data: T }
  | { valid: false; errors: { field: string; message: string }[] };

// Archivo: users/users.service.ts
import { Injectable } from '@nestjs/common';
import { validate } from 'class-validator';
import { plainToClass } from 'class-transformer';
import { CreateUserDto } from './dtos/create-user.dto';
import { ValidationResult } from '../shared/types/validation-result';

@Injectable()
export class UsersService {
  async validateCreateUserDto(dto: CreateUserDto): Promise<ValidationResult<CreateUserDto>> {
    const classDto = plainToClass(CreateUserDto, dto);
    const errors = await validate(classDto);

    if (errors.length > 0) {
      return {
        valid: false,
        errors: errors.map(err => ({
          field: err.property,
          message: Object.values(err.constraints || {}).join(', ')
        }))
      };
    }

    return {
      valid: true,
      data: classDto
    };
  }
}
```

---

## Resumen: Lo Que Aprendiste {#resumen}

- ‚úÖ **Discriminator:** Una propiedad (`type`, `status`, `kind`) que identifica qu√© tipo realmente eres
- ‚úÖ **Narrowing Autom√°tico:** TypeScript entiende autom√°ticamente qu√© propiedades existen despu√©s de un check
- ‚úÖ **Switch vs If:** Switch es el est√°ndar para discriminated unions (3+ casos)
- ‚úÖ **Exhaustiveness Checking:** TypeScript te obliga a cubrir TODOS los casos
- ‚úÖ **State Management:** Redux-style actions, React hooks states con discriminated unions
- ‚úÖ **Result Types:** Manejo de √©xito/fracaso sin excepciones (patr√≥n Rust)
- ‚úÖ **API Responses:** Discriminar por c√≥digo HTTP o custom status
- ‚úÖ **M√∫ltiples Discriminadores:** Usar varias propiedades (`kind` + `priority`)
- ‚úÖ **NestJS Patterns:** Respuestas uniformes, excepciones personalizadas, validaci√≥n
- ‚úÖ **Pattern Matching:** Los discriminated unions son el equivalente de TypeScript al pattern matching

**Lo importante:** Discriminated Unions = **seguridad + claridad**. No necesit√°s `any`, no necesit√°s `try/catch`, TypeScript simplemente entiende exactamente qu√© tienes en cada rama.

---

## üìã Checklist: ¬øEntendiste Discriminated Unions?

- ‚úÖ Entiendo que un discriminator es una propiedad que identifica el tipo
- ‚úÖ Puedo crear un discriminated union: `type MyType = { type: 'a'; ... } | { type: 'b'; ... }`
- ‚úÖ TypeScript autom√°ticamente entiende qu√© propiedades existen despu√©s de un check
- ‚úÖ Entiendo exhaustiveness checking: si me falta un caso, TypeScript me avisa
- ‚úÖ Puedo usar `switch` con discriminators para pattern matching limpio
- ‚úÖ Puedo crear Result<T, E> para manejar √©xito/fracaso sin excepciones
- ‚úÖ Puedo discriminar por m√∫ltiples propiedades (e.g., `kind` + `priority`)
- ‚úÖ Entiendo c√≥mo usarlos en NestJS: respuestas uniformes, filtros de excepciones
- ‚úÖ Puedo crear tipos Redux-style con acciones discriminadas
- ‚úÖ Puedo usar discriminated unions para state management en React
- ‚úÖ Entiendo que discriminated unions previenen bugs al obligar a cubrir todos los casos

**üéØ Pr√≥ximo paso:** [9. Branded Types: Tipos Nominales y Value Objects](./9.Branded-Types[TypeScript].md)

**üéØ Recuerda:** Discriminated Unions transforman `A | B | C` en "s√© exactamente cu√°l eres, as√≠ puedo usar tus propiedades con confianza".