# üó∫Ô∏è Mapped Types: Iterar y Transformar Tipos

Ahora que dominamos **Generics**, **Utility Types** y **Conditional Types**. Ahora toca **Mapped Types**: el superpoder para transformar tipos iterando sobre sus propiedades.

Imagina que necesitas aplicar la misma transformaci√≥n a TODAS las propiedades de un tipo. Mapped types hacen exactamente eso. **Son como loops, pero para tipos.** ‚ú®

---

## üìö √çndice de Contenidos

1. **[¬øQu√© Son Mapped Types?](#qu√©-son-mapped-types)** - Conceptos fundamentales
2. **[Sintaxis: { [K in Keys]: Type }](#sintaxis-k-in-keys--type)** - La magia de iterar
3. **[Modifiers: +/- para ? y readonly](#modifiers--para--y-readonly)** - Agregar/remover propiedades
4. **[Key Remapping con 'as'](#key-remapping-con-as)** - Transformar nombres de keys
5. **[Filtrar Keys con Remapping](#filtrar-keys-con-remapping)** - Seleccionar propiedades
6. **[Mapped Types + Conditional Types](#mapped-types--conditional-types)** - Combinaciones poderosas
7. **[Recursive Mapped Types](#recursive-mapped-types)** - Estructuras anidadas
8. **[PickByType & OmitByType](#pickbytype--omitbytype)** - Filtrar por tipo de valor
9. **[Casos Pr√°cticos NestJS](#casos-pr√°cticos-nestjs)** - Aplicaciones reales
10. **[Resumen](#resumen-lo-que-aprendiste)** - Recap
11. **[Checklist](#-checklist-¬øentendiste-mapped-types)** - Validaci√≥n

---

## ¬øQu√© Son Mapped Types?

Un **mapped type** es un tipo que itera sobre las propiedades de otro tipo y las transforma.

Sintaxis base:

$$\{ [K \text{ in Keys }]: \text{Type} \}$$

**Lo clave:** En lugar de escribir cada propiedad manualmente, **TypeScript itera sobre ellas**.

**Ejemplo mental:**
```typescript
// Tengo User con 10 props
// Quiero hacer TODAS readonly
// Sin mapped types: reescribir todo manualmente ‚ùå
// Con mapped types: 1 l√≠nea ‚úÖ
```

---

## Sintaxis: { [K in Keys]: Type }

**¬øC√≥mo funciona?**

```typescript
type User = {
  id: string;
  name: string;
  email: string;
};

// "Por cada key K en User, crea propiedad opcional"
type PartialUser = {
  [K in keyof User]?: User[K];
};
// Type: { id?: string; name?: string; email?: string } ‚úÖ

// "Por cada key K en User, crea propiedad readonly"
type ReadonlyUser = {
  readonly [K in keyof User]: User[K];
};
// Type: { readonly id: string; readonly name: string; readonly email: string } ‚úÖ
```

### ¬øC√≥mo Funciona el Iterable?

```typescript
keyof User = 'id' | 'name' | 'email'
    ‚Üì
[K in 'id' | 'name' | 'email']
    ‚Üì
Itera cada K: 'id', 'name', 'email'
    ‚Üì
User[K] obtiene el tipo de cada value
```

### ¬øPor Qu√© Importa?

Sin mapped types:
```typescript
// ‚ùå Repetir manualmente
type Getters = {
  getId: () => string;
  getName: () => string;
  getEmail: () => string;
};
```

Con mapped types:
```typescript
// ‚úÖ Autom√°tico
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};
```

---

## Modifiers: +/- para ? y readonly

En mapped types puedes **agregar o remover** modifiers:

- `+?: agregar optional`
- `-?: remover optional (hacer required)`
- `+readonly: agregar readonly`
- `-readonly: remover readonly (hacer mutable)`

```typescript
// Remover ? ‚Üí hacer required
type Required<T> = {
  [K in keyof T]-?: T[K];
};

// Remover readonly ‚Üí hacer mutable
type Mutable<T> = {
  -readonly [K in keyof T]: T[K];
};

// Remover AMBOS
type MutableRequired<T> = {
  -readonly [K in keyof T]-?: T[K];
};
```

### Caso Real: Limpiar Tipo

```typescript
interface PartialReadonlyUser {
  readonly id?: string;
  readonly name?: string;
  email?: string;
}

// Remover todos los modifiers
type CleanUser = MutableRequired<PartialReadonlyUser>;
// Type: { id: string; name: string; email: string } ‚úÖ

const user: CleanUser = {
  id: '1',
  name: 'John',
  email: 'john@example.com',
};

user.id = '2'; // ‚úÖ Mutable!
```

---

## Key Remapping con 'as'

**Key remapping** permite transformar los NOMBRES de las propiedades durante el mapping.

```typescript
// Agregar prefijo 'get' a todas las props
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

type User = { id: string; name: string; email: string };
type UserGetters = Getters<User>;
// Type: {
//   getId: () => string;
//   getName: () => string;
//   getEmail: () => string;
// } ‚úÖ
```

### Caso Real: Generar Nombres de Eventos

```typescript
// Transformar "name" ‚Üí "nameChanged", "id" ‚Üí "idChanged"
type Events<T> = {
  [K in keyof T as `${string & K}Changed`]: (newValue: T[K]) => void;
};

type UserEvents = Events<User>;
// Type: {
//   idChanged: (newValue: string) => void;
//   nameChanged: (newValue: string) => void;
//   emailChanged: (newValue: string) => void;
// } ‚úÖ
```

---

## Filtrar Keys con Remapping

Combinando remapping con condicionales, puedes filtrar propiedades:

```typescript
// "Si T[K] es string, mantenla; si no, desc√°rtala (never)"
type StringPropsOnly<T> = {
  [K in keyof T as T[K] extends string ? K : never]: T[K];
};

interface Mixed {
  id: string;
  name: string;
  age: number;
  active: boolean;
}

type OnlyStrings = StringPropsOnly<Mixed>;
// Type: { id: string; name: string } ‚úÖ
// number y boolean desaparecen autom√°ticamente
```

---

## Mapped Types + Conditional Types

Combinarlos es POTENTE:

```typescript
// Hacer nullable SOLO las props especificadas
type Nullable<T, K extends keyof T> = {
  [P in keyof T]: P extends K ? T[P] | null : T[P];
};

type User = { id: string; name: string; email: string };
type UserWithNullableEmail = Nullable<User, 'email'>;
// Type: {
//   id: string;
//   name: string;
//   email: string | null; ‚úÖ
// }
```

### Caso Real: Generar DTOs

```typescript
interface Product {
  id: string;
  name: string;
  price: number;
  stock: number;
  createdAt: Date;
  updatedAt: Date;
}

// Update DTO: partial, EXCEPTO id y timestamps
type UpdateProductDto = {
  [P in keyof Product as P extends 'id' | 'createdAt' | 'updatedAt'
    ? never
    : P]?: Product[P];
};
// Type: { name?: string; price?: number; stock?: number } ‚úÖ

const update: UpdateProductDto = {
  name: 'New Name',
  price: 99.99,
  // id no puede estar ‚ùå
  // createdAt no puede estar ‚ùå
};
```

---

## Recursive Mapped Types

**Mapped types que se llaman a s√≠ mismos** para estructuras anidadas.

```typescript
// DeepPartial: optional recursivamente
type DeepPartial<T> = {
  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};

interface Config {
  server: {
    host: string;
    port: number;
    ssl: { enabled: boolean; certPath: string };
  };
  database: { host: string; port: number };
}

type PartialConfig = DeepPartial<Config>;

const config: PartialConfig = {
  server: {
    ssl: {
      enabled: true, // Solo esto, certPath opcional ‚úÖ
    },
    // host, port opcionales ‚úÖ
  },
  // database completamente opcional ‚úÖ
};
```

---

## PickByType & OmitByType

Filtrar din√°micamente por tipo de valor:

```typescript
// "Dame solo las props cuyo value es de tipo V"
type PickByType<T, V> = {
  [K in keyof T as T[K] extends V ? K : never]: T[K];
};

// "Dame todas las props EXCEPTO las de tipo V"
type OmitByType<T, V> = {
  [K in keyof T as T[K] extends V ? never : K]: T[K];
};

interface Article {
  id: string;
  title: string;
  content: string;
  views: number;
  likes: number;
  publishedAt: Date;
}

// Solo props string
type ArticleStrings = PickByType<Article, string>;
// Type: { id: string; title: string; content: string } ‚úÖ

// Solo props number
type ArticleNumbers = PickByType<Article, number>;
// Type: { views: number; likes: number } ‚úÖ

// SIN props string
type ArticleNoStrings = OmitByType<Article, string>;
// Type: { views: number; likes: number; publishedAt: Date } ‚úÖ
```

---

## Casos Pr√°cticos NestJS

Aqu√≠ es donde todo brilla.

### 1. API Response Wrapper Type-Safe

```typescript
type ApiResponse<T> = {
  data: T;
  meta: { timestamp: string; requestId: string };
  // Agregar URLs para cada prop
  [K in keyof T as `${string & K}Url`]?: string;
};

interface User {
  id: string;
  name: string;
  avatar: string;
}

type UserResponse = ApiResponse<User>;
// Type: {
//   data: User;
//   meta: { timestamp: string; requestId: string };
//   idUrl?: string;        // URLs para recursos
//   nameUrl?: string;
//   avatarUrl?: string;
// } ‚úÖ

@Controller('users')
export class UserController {
  @Get()
  async getUsers(): Promise<UserResponse> {
    const users = await this.userService.findAll();
    return {
      data: users,
      meta: {
        timestamp: new Date().toISOString(),
        requestId: 'req-123',
      },
      idUrl: '/users/123', // URLs opcionales
      avatarUrl: '/avatars/user.jpg',
    };
  }
}
```

### 2. Validation Rules Type-Safe

```typescript
type ValidationRules<T> = {
  [K in keyof T]?: T[K] extends string
    ? { minLength?: number; maxLength?: number; pattern?: RegExp }
    : T[K] extends number
    ? { min?: number; max?: number }
    : T[K] extends boolean
    ? { required?: boolean }
    : never;
};

interface CreateUserDto {
  name: string;
  email: string;
  age: number;
  acceptTerms: boolean;
}

const validationRules: ValidationRules<CreateUserDto> = {
  name: { minLength: 3, maxLength: 50 }, // Solo para string ‚úÖ
  email: { pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/ },
  age: { min: 18, max: 120 }, // Solo para number ‚úÖ
  acceptTerms: { required: true }, // Solo para boolean ‚úÖ
};

// TypeScript asegura que rules coincidan con tipo de field!
```

### 3. Database Schema Mapping

```typescript
type DbColumnType<T> = T extends string
  ? 'varchar' | 'text'
  : T extends number
  ? 'int' | 'decimal'
  : T extends boolean
  ? 'boolean'
  : T extends Date
  ? 'timestamp'
  : 'unknown';

type DbSchema<T> = {
  [K in keyof T]: {
    type: DbColumnType<T[K]>;
    nullable?: boolean;
    unique?: boolean;
  };
};

interface User {
  id: string;
  name: string;
  email: string;
}

type UserSchema = DbSchema<User>;

const userSchema: UserSchema = {
  id: { type: 'varchar', unique: true },
  name: { type: 'varchar' },
  email: { type: 'varchar', unique: true },
  // ‚ùå No puedes poner type: 'int' porque id es string
};
```

### 4. Event Handlers Type-Safe

```typescript
type EventHandlers<T> = {
  [K in keyof T as `on${Capitalize<string & K>}Change`]: (
    oldValue: T[K],
    newValue: T[K],
  ) => void;
};

type User = { id: string; name: string; email: string };
type UserEventHandlers = EventHandlers<User>;
// Type: {
//   onIdChange: (oldValue: string, newValue: string) => void;
//   onNameChange: (oldValue: string, newValue: string) => void;
//   onEmailChange: (oldValue: string, newValue: string) => void;
// } ‚úÖ

class UserObservable {
  private handlers: Partial<UserEventHandlers> = {};

  on<K extends keyof UserEventHandlers>(
    event: K,
    handler: UserEventHandlers[K],
  ): void {
    this.handlers[event] = handler;
  }

  emit<K extends keyof UserEventHandlers>(
    event: K,
    ...args: Parameters<UserEventHandlers[K]>
  ): void {
    this.handlers[event]?.(...args);
  }
}

// Uso type-safe:
const observable = new UserObservable();

observable.on('onNameChange', (oldName, newName) => {
  console.log(`${oldName} ‚Üí ${newName}`);
});

observable.emit('onNameChange', 'John', 'Jane'); // ‚úÖ Type-safe

// observable.emit('onNameChange', 123, 456); 
// ‚ùå Error: esperaba strings
```

### 5. Service Methods Generator

```typescript
type ServiceMethods<E extends 'user' | 'product' | 'order'> = {
  [K in
    | `find${Capitalize<E>}`
    | `create${Capitalize<E>}`
    | `update${Capitalize<E>}`
    | `delete${Capitalize<E>}`]: K extends `find${string}`
    ? (id: string) => Promise<any>
    : K extends `create${string}`
    ? (data: any) => Promise<any>
    : K extends `update${string}`
    ? (id: string, data: any) => Promise<any>
    : K extends `delete${string}`
    ? (id: string) => Promise<void>
    : never;
};

type UserService = ServiceMethods<'user'>;
// Type: {
//   findUser: (id: string) => Promise<any>;
//   createUser: (data: any) => Promise<any>;
//   updateUser: (id: string, data: any) => Promise<any>;
//   deleteUser: (id: string) => Promise<void>;
// } ‚úÖ

// Ahora la implementaci√≥n est√° type-safe contra esta interfaz
@Injectable()
export class UserService implements UserService {
  async findUser(id: string): Promise<any> {
    // ‚úÖ Signature debe coincidir exactamente
    return this.repo.findOne(id);
  }

  async createUser(data: any): Promise<any> {
    return this.repo.create(data);
  }

  // etc...
}
```

---

## Resumen: Lo Que Aprendiste

- ‚úÖ **Sintaxis:** `{ [K in Keys]: Type }` (loops para tipos)
- ‚úÖ **Modifiers:** `+?` `-?` `+readonly` `-readonly` para agregar/remover
- ‚úÖ **Key Remapping:** `as` para transformar nombres de propiedades
- ‚úÖ **Filtrar Keys:** Usar `never` en remapping para excluir
- ‚úÖ **Recursive:** Mapped types que se llaman a s√≠ mismos
- ‚úÖ **Condicionales:** Combinar con `conditional types` para l√≥gica compleja
- ‚úÖ **PickByType/OmitByType:** Filtrar din√°micamente por tipo de valor
- ‚úÖ **Real-World:** Validadores, handlers, schemas, DTOs ‚Äî todo type-safe

**Lo importante:** Mapped types = **DRY para tipos**. Una vez que definas una transformaci√≥n, se aplica autom√°ticamente a todas las propiedades. ¬°Escribes c√≥digo que genera tipos! ü§ñ

---

## üìã Checklist: ¬øEntendiste Mapped Types? Tengamos presente lo siguiente:

- ‚úÖ Sintaxis: `{ [K in keyof T]: Type }`
- ‚úÖ Modifiers: `+?` `-?` `+readonly` `-readonly`
- ‚úÖ Key remapping con `as` para transformar nombres
- ‚úÖ Filtrar keys con `never` en remapping
- ‚úÖ Combinaci√≥n con conditional types
- ‚úÖ Recursive mapped types para estructuras anidadas
- ‚úÖ PickByType y OmitByType para filtrar por tipo
- ‚úÖ Generar m√©todos, handlers, validadores autom√°ticamente
- ‚úÖ Type-safe event emitters y observables
- ‚úÖ API responses, schemas, DTOs ‚Äî todo generado

**üéØ Pr√≥ximo paso:** [5Ô∏è‚É£ Template Literal Types](./5.Template-Literal-Types[TypeScript].md) ‚Äî Tipos strings din√°micos y pattern matching.

**üéØ Recuerda:** Mapped types son tu herramienta para automatizar transformaciones de tipos. Cuanto m√°s los uses, menos c√≥digo duplicado escribir√°s.

