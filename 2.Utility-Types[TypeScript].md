# üõ†Ô∏è Utility Types: Transformaciones de Tipos Built-in

Despu√©s de dominar Generics, ahora vamos con **Utility Types**. Estos son "tipos sobre tipos" que TypeScript proporciona para transformar tipos existentes. Los vas a usar TODO EL TIEMPO en NestJS, especialmente para DTOs.

---

## ÔøΩ √çndice de Contenidos

1. **[¬øQu√© Son Utility Types?](#qu√©-son-utility-types)** - Introducci√≥n conceptual
2. **[Partial<T>: Propiedades Opcionales](#partialt-propiedades-opcionales)** - Para updates
3. **[Required<T>: Propiedades Obligatorias](#requiredt-propiedades-obligatorias)** - Lo opuesto a Partial
4. **[Readonly<T>: Propiedades Inmutables](#readonlyt-propiedades-inmutables)** - Value Objects
5. **[Pick<T, K>: Seleccionar Propiedades](#pickt-k-seleccionar-propiedades)** - Response DTOs
6. **[Omit<T, K>: Excluir Propiedades](#omitt-k-excluir-propiedades)** - Create DTOs
7. **[Record<K, T>: Mapas Type-Safe](#recordk-t-mapas-type-safe)** - Configuraciones
8. **[Exclude & Extract: Filtrar Unions](#exclude--extract-filtrar-unions)** - Manipular unions
9. **[NonNullable<T>: Remover null/undefined](#nonnullablet-remover-nullundefined)** - Garantizar valores
10. **[ReturnType & Parameters: Inferir Tipos](#returntype--parameters-inferir-tipos)** - De funciones
11. **[Awaited<T>: Resolver Promises](#awaitedt-resolver-promises)** - De async functions
12. **[Combinando Utility Types](#combinando-utility-types)** - Casos complejos
13. **[Resumen](#resumen-lo-que-aprendiste)** - Lo que aprendiste
14. **[Checklist](#-checklist-¬øentendiste-utility-types)** - Validaci√≥n

---

## ¬øQu√© Son Utility Types?

Imagina que tienes una `interface User` completa con 10 propiedades. Ahora necesitas:

- Un **UpdateUserDto** donde TODAS las props son opcionales (porque en un PATCH puedo actualizar solo un campo)
- Un **CreateUserDto** sin `id` ni `createdAt` (porque el servidor las genera)
- Un **UserResponse** sin la contrase√±a (por seguridad)
- Una mapa de roles ‚Üí permisos type-safe

Sin utility types, tendr√≠as que crear nuevas interfaces manualmente para cada caso. **Aburrido y propenso a errores.**

Con utility types, TypeScript **transforma tipos autom√°ticamente**. Es como magia, pero con type safety. üéâ

---

## Partial<T>: Propiedades Opcionales

**Caso:** Update DTO donde todos los campos son opcionales.

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'user';
  createdAt: Date;
}

// Caso: Update DTO donde todos los campos son opcionales

// ‚ùå Sin Partial: tendr√≠as que escribir esto manualmente
type UpdateUserDtoManual = {
  id?: string;
  name?: string;
  email?: string;
  role?: 'admin' | 'user';
};

// ‚úÖ Con Partial: autom√°tico
type UpdateUserDto = Partial<User>;

// Uso
const update: UpdateUserDto = {
  name: 'John Updated', // ‚úÖ Solo name, resto opcional
};
```

### ¬øC√≥mo Funciona?

`Partial<T>` itera sobre cada propiedad de `T` y la hace opcional con `?`. Es como si dijera: "Toma todas las props de User, pero hazlas opcionales."

### Caso Real en NestJS: Update Service

```typescript
@Injectable()
export class UserService {
  constructor(private userRepository: Repository<User>) {}

  // Actualizar parcialmente
  async update(id: string, data: Partial<User>): Promise<User> {
    // data puede tener CUALQUIER combinaci√≥n de campos
    await this.userRepository.update(id, data);
    return this.findById(id);
  }
}

// En Controller
@Patch(':id')
async updateUser(
  @Param('id') id: string,
  @Body() data: Partial<User>, // ‚úÖ Type-safe: solo props de User
): Promise<User> {
  return this.userService.update(id, data);
}

// Uso correcto
await updateUser('123', { name: 'Jane' }); // ‚úÖ
await updateUser('123', { name: 'Jane', role: 'admin' }); // ‚úÖ
// await updateUser('123', { invalidField: 'x' }); // ‚ùå Error: no es prop de User
```

---

## Required<T>: Propiedades Obligatorias

**Caso:** Lo opuesto a Partial. Tienes un tipo con props opcionales pero en ciertos contextos necesitas que TODAS sean obligatorias.

```typescript
interface UserConfig {
  theme?: 'light' | 'dark';
  notifications?: boolean;
  language?: string;
}

// ‚ùå Sin Required: podr√≠as crear config vac√≠o
const config1: UserConfig = {}; // ‚úÖ V√°lido pero vac√≠o

// ‚úÖ Con Required: OBLIGATORIO llenar todos
type CompleteUserConfig = Required<UserConfig>;

const config2: CompleteUserConfig = {
  theme: 'dark', // ‚úÖ Obligatorio
  notifications: true, // ‚úÖ Obligatorio
  language: 'es', // ‚úÖ Obligatorio
};

// const incomplete: CompleteUserConfig = { theme: 'dark' }; // ‚ùå Error: faltan fields
```

### ¬øPor Qu√© lo Usamos?

Cuando procesas datos despu√©s de validaci√≥n. El validador debe garantizar que todos los campos existen, as√≠ que usas `Required<T>` despu√©s de validar.

---

## Readonly<T>: Propiedades Inmutables

**Caso:** Crear tipos que NO pueden ser modificados. √ötil para Value Objects y configuraciones inmutables.

```typescript
type ImmutableUser = Readonly<User>;

const user: ImmutableUser = {
  id: '1',
  name: 'John',
  email: 'john@example.com',
  role: 'user',
  createdAt: new Date(),
};

// user.name = 'Jane'; // ‚ùå Error: Cannot assign to 'name' because it is read-only
```

### Caso Real: Value Object Email

En DDD (Domain-Driven Design), los Value Objects son inmutables:

```typescript
// Email como Value Object inmutable
class Email {
  private readonly _value: string;

  private constructor(value: string) {
    this._value = value;
  }

  // Factory method: validar y crear
  static create(value: string): Email {
    if (!value.includes('@')) {
      throw new Error('‚ùå Email inv√°lido');
    }
    return new Email(value);
  }

  // Getter: solo lectura
  get value(): string {
    return this._value;
  }

  // M√©todos √∫tiles
  isGmail(): boolean {
    return this._value.endsWith('@gmail.com');
  }
}

// Uso
const email = Email.create('john@gmail.com'); // ‚úÖ
console.log(email.value); // john@gmail.com
// email._value = 'hacked@evil.com'; // ‚ùå Error: readonly
```

---

## Pick<T, K>: Seleccionar Propiedades

**Caso:** Solo quieres ALGUNAS propiedades de un tipo. Perfecto para Response DTOs.

```typescript
// Solo id y name
type UserPreview = Pick<User, 'id' | 'name'>;

const preview: UserPreview = {
  id: '1',
  name: 'John',
  // email, password, role NO est√°n disponibles ‚úÖ
};

// password NO puede estar aqu√≠
// const bad: UserPreview = { id: '1', password: 'secret' }; // ‚ùå Error
```

### Caso Real: Response DTOs en NestJS

```typescript
// Entity con TODOS los datos (incluyendo sensibles)
interface Order {
  id: string;
  userId: string;
  items: OrderItem[];
  total: number;
  status: 'pending' | 'completed' | 'cancelled';
  paymentMethod: string;
  shippingAddress: Address;
  createdAt: Date;
  updatedAt: Date;
}

// Response para LISTADO: solo info b√°sica
type OrderListItemDto = Pick<Order, 'id' | 'total' | 'status' | 'createdAt'>;
// Type: { id: string; total: number; status: string; createdAt: Date } ‚úÖ

// Response para DETALLE: m√°s campos pero NO payment internos
type OrderDetailDto = Pick<
  Order,
  'id' | 'items' | 'total' | 'status' | 'shippingAddress' | 'createdAt'
>;

@Controller('orders')
export class OrderController {
  constructor(private orderService: OrderService) {}

  @Get()
  async listOrders(): Promise<OrderListItemDto[]> {
    // Retorna solo campos necesarios
    const orders = await this.orderService.findAll();
    // ‚úÖ TypeScript asegura que SOLO retorna pick fields
    return orders;
  }

  @Get(':id')
  async getOrder(@Param('id') id: string): Promise<OrderDetailDto> {
    // Retorna m√°s detalle pero NO payment info
    return this.orderService.findById(id);
  }
}
```

---

## Omit<T, K>: Excluir Propiedades

**Caso:** Lo opuesto a Pick. Quieres CASI todas las propiedades, EXCEPTO algunas.

```typescript
// Todo EXCEPTO password y timestamps
type UserWithoutSensitive = Omit<User, 'password' | 'createdAt' | 'updatedAt'>;

const user: UserWithoutSensitive = {
  id: '1',
  name: 'John',
  email: 'john@example.com',
  // password, createdAt, updatedAt NO disponibles ‚úÖ
};
```

### Caso Real: Create DTO sin IDs/Timestamps

```typescript
interface Product {
  id: string; // ‚ùå Auto-generado por DB
  name: string;
  description: string;
  price: number;
  stock: number;
  createdAt: Date; // ‚ùå Auto-generado por DB
  updatedAt: Date; // ‚ùå Auto-generado por DB
}

// Create DTO: SIN id, timestamps
type CreateProductDto = Omit<Product, 'id' | 'createdAt' | 'updatedAt'>;

@Controller('products')
export class ProductController {
  @Post()
  async createProduct(
    @Body() dto: CreateProductDto, // ‚úÖ No tiene id/timestamps
  ): Promise<Product> {
    // El servidor genera id y timestamps
    return this.productService.create(dto);
  }
}

// Uso
const newProduct: CreateProductDto = {
  name: 'Laptop',
  description: 'Gaming laptop',
  price: 1500,
  stock: 10,
  // ‚ùå No puedo poner id, createdAt, updatedAt
};
```

---

## Record<K, T>: Mapas Type-Safe

**Caso:** Crear un objeto que funciona como mapa: cada KEY tiene un VALUE de tipo T.

```typescript
// Mapa simple: role ‚Üí permisos
type RolePermissions = Record<string, string[]>;

const permissions: RolePermissions = {
  admin: ['read', 'write', 'delete'],
  user: ['read'],
  guest: [],
};

// CON UNION TYPES: Solo keys v√°lidas
type UserRole = 'admin' | 'user' | 'guest';
type StrictRolePermissions = Record<UserRole, string[]>;

const strictPermissions: StrictRolePermissions = {
  admin: ['read', 'write', 'delete'],
  user: ['read'],
  guest: [],
  // 'invalid': [] // ‚ùå Error: 'invalid' NO es UserRole
};
```

### ¬øC√≥mo Funciona?

`Record<K, T>` dice: "Crea un objeto donde cada KEY de K tiene un VALUE de tipo T."

### Caso Real: Configuraciones por Ambiente

```typescript
type Environment = 'development' | 'staging' | 'production';

type DatabaseConfig = {
  host: string;
  port: number;
  database: string;
  ssl: boolean;
};

// Garantiza que TODOS los ambientes tienen configuraci√≥n
type DatabaseConfigs = Record<Environment, DatabaseConfig>;

const dbConfigs: DatabaseConfigs = {
  development: {
    host: 'localhost',
    port: 5432,
    database: 'myapp_dev',
    ssl: false,
  },
  staging: {
    host: 'staging.db.example.com',
    port: 5432,
    database: 'myapp_staging',
    ssl: true,
  },
  production: {
    host: 'prod.db.example.com',
    port: 5432,
    database: 'myapp_prod',
    ssl: true,
  },
  // 'invalid': { ... } // ‚ùå Error: debe ser development|staging|production
};

@Injectable()
export class ConfigService {
  private configs: DatabaseConfigs = dbConfigs;

  getDatabaseConfig(env: Environment): DatabaseConfig {
    return this.configs[env]; // ‚úÖ Type-safe
  }
}

// Uso
const devDb = new ConfigService().getDatabaseConfig('development');
// devDb.host = 'localhost' ‚úÖ
// Type: DatabaseConfig
```

---

## Exclude & Extract: Filtrar Unions

**Caso:** Tienes una union de tipos y quieres REMOVER o EXTRAER tipos espec√≠ficos.

### Exclude: Remover de Union

```typescript
type Status = 'pending' | 'processing' | 'completed' | 'failed';

// Solo estados activos (remover completed/failed)
type ActiveStatus = Exclude<Status, 'completed' | 'failed'>;
// Type: 'pending' | 'processing' ‚úÖ

const active: ActiveStatus = 'pending'; // ‚úÖ
const processing: ActiveStatus = 'processing'; // ‚úÖ
// const done: ActiveStatus = 'completed'; // ‚ùå Error: no est√° en ActiveStatus
```

### Extract: Mantener solo lo que coincide

```typescript
type AllEvents =
  | 'user.created'
  | 'user.updated'
  | 'user.deleted'
  | 'order.created'
  | 'order.completed'
  | 'payment.received';

// Solo eventos de usuario (que matchean `user.${string}`)
type UserEvents = Extract<AllEvents, `user.${string}`>;
// Type: 'user.created' | 'user.updated' | 'user.deleted' ‚úÖ

// Solo eventos NO de usuario
type NonUserEvents = Exclude<AllEvents, `user.${string}`>;
// Type: 'order.created' | 'order.completed' | 'payment.received' ‚úÖ
```

### Caso Real: Event Listeners Type-Safe

```typescript
interface EventHandlers {
  'user.created': (userId: string) => void;
  'user.updated': (userId: string, changes: Partial<User>) => void;
  'user.deleted': (userId: string) => void;
  'order.created': (orderId: string) => void;
}

// Solo handlers de user
type UserEventHandlers = Pick<EventHandlers, Extract<keyof EventHandlers, `user.${string}`>>;

class EventEmitter {
  private userHandlers: Partial<UserEventHandlers> = {};

  onUserEvent<E extends Extract<keyof EventHandlers, `user.${string}`>>(
    event: E,
    handler: EventHandlers[E],
  ): void {
    this.userHandlers[event] = handler;
  }
}
```

---

## NonNullable<T>: Remover null/undefined

**Caso:** Garantizar que un tipo NO puede ser null o undefined.

```typescript
type MaybeString = string | null | undefined;

// Remover null y undefined
type DefinitelyString = NonNullable<MaybeString>;
// Type: string ‚úÖ

const value1: DefinitelyString = 'hello'; // ‚úÖ
// const value2: DefinitelyString = null; // ‚ùå Error
// const value3: DefinitelyString = undefined; // ‚ùå Error
```

### Caso Real: Validaci√≥n de Datos

```typescript
interface UserInput {
  name?: string;
  email?: string;
  phone?: string | null;
}

// Despu√©s de validaci√≥n: todo es requerido y no nullable
type ValidatedUser = {
  [K in keyof UserInput]-?: NonNullable<UserInput[K]>;
};
// Type: {
//   name: string;
//   email: string;
//   phone: string;  ‚Üê sin null
// } ‚úÖ

function createUser(user: ValidatedUser): void {
  console.log(user.name); // Type: string, nunca null ‚úÖ
}
```

---

## ReturnType & Parameters: Inferir Tipos

### ReturnType: Tipo de Retorno

```typescript
function getUser() {
  return {
    id: '1',
    name: 'John',
    email: 'john@example.com',
  };
}

// Extraer tipo de retorno autom√°ticamente
type UserFromFunction = ReturnType<typeof getUser>;
// Type: { id: string; name: string; email: string } ‚úÖ

// Sin duplicar la definici√≥n del tipo
```

### Parameters: Tipos de Par√°metros

```typescript
function createUser(name: string, email: string, age: number) {
  // ...
}

// Extraer par√°metros como tuple
type CreateUserParams = Parameters<typeof createUser>;
// Type: [name: string, email: string, age: number] ‚úÖ

const params: CreateUserParams = ['John', 'john@example.com', 30];
```

### Caso Real: Inferir del Service

```typescript
@Injectable()
export class OrderService {
  async createOrder(data: CreateOrderDto) {
    // L√≥gica compleja...
    return {
      id: 'uuid-123',
      ...data,
      status: 'pending' as const,
      createdAt: new Date(),
    };
  }
}

// Inferir tipo exacto del retorno SIN duplicar definici√≥n
type CreatedOrder = Awaited<ReturnType<OrderService['createOrder']>>;
// Type: { id: string; ...CreateOrderDto; status: 'pending'; createdAt: Date } ‚úÖ

// Ahora siempre est√° sincronizado con el m√©todo real
```

---

## Awaited<T>: Resolver Promises

**Caso:** Tienes un `Promise<T>` pero necesitas solo `T`. √ötil para async functions.

```typescript
async function fetchUser(): Promise<User> {
  // ...
  return {} as User;
}

// ‚ùå Sin Awaited: tipo es Promise<User>
type PromiseType = ReturnType<typeof fetchUser>;
// Type: Promise<User>

// ‚úÖ Con Awaited: tipo es User
type FetchedUser = Awaited<ReturnType<typeof fetchUser>>;
// Type: User ‚úÖ

// Con promises anidadas (resuelve recursivamente)
type NestedPromise = Promise<Promise<Promise<string>>>;
type Resolved = Awaited<NestedPromise>;
// Type: string ‚úÖ (desenvuelve todos los niveles)
```

---

## Combinando Utility Types

Los superpoderes vienen cuando **combinan m√∫ltiples utility types** para casos complejos.

```typescript
interface Article {
  id: string;
  title: string;
  content: string;
  authorId: string;
  published: boolean;
  tags: string[];
  createdAt: Date;
  updatedAt: Date;
}

// CREATE DTO: sin id, sin timestamps, published es opcional
type CreateArticleDto = Omit<Article, 'id' | 'createdAt' | 'updatedAt'> & {
  published?: boolean; // Override: hacer opcional
};

// UPDATE DTO: partial + excluir sensibles
type UpdateArticleDto = Partial<Omit<Article, 'id' | 'createdAt' | 'updatedAt'>>;

// RESPONSE DTO: sin authorId (reemplazar con author completo)
type ArticleResponseDto = Omit<Article, 'authorId'> & {
  author: Pick<User, 'id' | 'name' | 'avatar'>; // Include author info
};

// Uso
@Controller('articles')
export class ArticleController {
  @Post()
  async create(@Body() dto: CreateArticleDto): Promise<ArticleResponseDto> {
    return this.articleService.create(dto);
  }

  @Patch(':id')
  async update(
    @Param('id') id: string,
    @Body() dto: UpdateArticleDto,
  ): Promise<ArticleResponseDto> {
    return this.articleService.update(id, dto);
  }

  @Get(':id')
  async getOne(@Param('id') id: string): Promise<ArticleResponseDto> {
    return this.articleService.findById(id);
  }
}
```

---

## Resumen: Lo Que Aprendiste

- ‚úÖ **Partial<T>:** Todas las props opcionales ‚Üí Update DTOs
- ‚úÖ **Pick<T, K>:** Seleccionar props ‚Üí Response DTOs p√∫blicas
- ‚úÖ **Omit<T, K>:** Excluir props ‚Üí Create DTOs
- ‚úÖ **Record<K, T>:** Mapas type-safe ‚Üí Configuraciones
- ‚úÖ **Readonly<T>:** Immutabilidad ‚Üí Value Objects
- ‚úÖ **Required<T>:** Todas las props obligatorias ‚Üí Validaci√≥n
- ‚úÖ **NonNullable<T>:** Remover null/undefined ‚Üí Garantizar valores
- ‚úÖ **Exclude/Extract:** Filtrar unions ‚Üí Event types
- ‚úÖ **ReturnType/Parameters:** Inferir de funciones ‚Üí Evitar duplicaci√≥n
- ‚úÖ **Awaited<T>:** Resolver promises ‚Üí Async functions
- ‚úÖ **Combinaciones:** M√∫ltiples utilities juntas ‚Üí Casos complejos

**Lo importante:** Utility Types son **transformaciones autom√°ticas de tipos**. Te ahorran escribir c√≥digo repetitivo y mantienen todo sincronizado. Si cambias la Entity, los DTOs se adaptan autom√°ticamente. ¬°Magia! ‚ú®

---

## üìã Checklist: ¬øEntendiste Utility Types? Tengamos presente lo siguiente:

- ‚úÖ Partial<T> para Update DTOs
- ‚úÖ Pick<T, K> para Response DTOs
- ‚úÖ Omit<T, K> para Create DTOs
- ‚úÖ Record<K, T> para mapas type-safe
- ‚úÖ Readonly<T> para inmutabilidad
- ‚úÖ Required<T> para forzar completitud
- ‚úÖ NonNullable<T> para garantizar valores
- ‚úÖ ReturnType/Parameters para inferir tipos
- ‚úÖ Awaited<T> para promises
- ‚úÖ Combinar m√∫ltiples utilities para casos avanzados

**üéØ Pr√≥ximo paso:** [3Ô∏è‚É£ Conditional Types](./3.Conditional-Types[TypeScript].md) ‚Äî Tipos que cambian seg√∫n condiciones (como ternarios pero para tipos).

**üéØ Recuerda:** Utility Types NO son "magia extra√±a". Son helpers que TypeScript proporciona para el trabajo cotidiano. Dom√≠nalos y escribir√°s c√≥digo m√°s limpio y seguro.